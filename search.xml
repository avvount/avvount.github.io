<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[笔记存档]]></title>
    <url>%2F2019%2F04%2F19%2F%E7%AC%94%E8%AE%B0%E5%AD%98%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[统计宽字节的字符串长度12wchar_t *p="aaa"; int len=wcslen(p2); CString 转 char *1234CString str("aaa");CSringA tmp; tmp=str; char *p=tmp.GetBuffer(); 事件对象与互斥对象都属于内核对象添加自定义消息 定义消息宏 Eg:1#define WM_RECVDATA WM_USER+1 在头文件中添加消息响应函数原型声明 Eg:1afx_msg LRESULT OnrecvData(WPARAM wParam,LPARAM lParam); 在源文件中BEGIN_MESSAGE_MAP( )和END_MESSAGE_MAP()之间添加消息映射，不要写在//}}AFX_MSG_MAP宏之间 Eg:1ON_MESSAGE(WM_RECVDATA,OnRecvData) 编写消息响应函数的实现 在引发或发出消息的地方使用SendMessage或PostMessage发送消息 类的动态创建在头文件中添加DECLARE_DYNCREATE(class_name)宏，源文件中添加IMPLEMENT_DYNCREATE(class_name , base_class_name)宏。 Sublime快捷键设置 Ctrl + hjkl快速移动光标,在首选项-&gt;快捷键设置中添加以下代码 12345678[ &#123; "keys": ["ctrl+h"], "command": "move", "args": &#123;"by": "characters", "forward": false&#125; &#125;, &#123; "keys": ["ctrl+l"], "command": "move", "args": &#123;"by": "characters", "forward": true&#125; &#125;, &#123; "keys": ["ctrl+k"], "command": "move", "args": &#123;"by": "lines", "forward": false&#125; &#125;, &#123; "keys": ["ctrl+j"], "command": "move", "args": &#123;"by": "lines", "forward": true&#125; &#125;, &#123; "keys": ["ctrl+shift+h"], "command": "move", "args": &#123;"by": "words", "forward": false&#125; &#125;, &#123; "keys": ["ctrl+shift+l"], "command": "move", "args": &#123;"by": "word_ends", "forward": true&#125; &#125;,] 开启vim模式 在用户设置中将Vintage从ignored_packages中删除 SQL 同时count多个表的数据12345678910111213SELECT SUM(Info),SUM(K),SUM(Raw) FROM ( SELECT COUNT(*) Info,0 K,0 Raw FROM information UNION ALL SELECT 0 Info,COUNT(*) K,0 Raw FROM kline UNION ALL SELECT 0 Info,0 K,COUNT(*) Raw FROM update1)t;]]></content>
  </entry>
  <entry>
    <title><![CDATA[终端复用工具tmux]]></title>
    <url>%2F2018%2F11%2F28%2Ftmux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[快捷键一般情况下 tmux 中所有的快捷键都需要和前缀快捷键 Ctrl+b 来组合使用，以下是常用的窗格（pane）快捷键列表，大家可以依次尝试下： ? 可以查看所有的快捷键列表 窗格操作 % 左右平分出两个窗格*” 上下平分出两个窗格 x 关闭当前窗格 { 当前窗格前移 } 当前窗格后移 ; 选择上次使用的窗格 o 选择下一个窗格，也可以使用上下左右方向键来选择 space 切换窗格布局，tmux 内置了五种窗格布局，也可以通过 ⌥1 至 ⌥5来切换 z 最大化当前窗格，再次执行可恢复原来大小 q 显示所有窗格的序号，在序号出现期间按下对应的数字，即可跳转至对应的窗格 窗口操作tmux 除了窗格以外，还有窗口（window） 的概念。依次使用以下快捷键来熟悉 tmux 的窗口操作： c 新建窗口，此时当前窗口会切换至新窗口，不影响原有窗口的状态 p 切换至上一窗口 n 切换至下一窗口 w 窗口列表选择，注意 macOS 下使用 ⌃p 和 ⌃n 进行上下选择 &amp; 关闭当前窗口 , 重命名窗口，可以使用中文，重命名后能在 tmux 状态栏更快速的识别窗口 id 0 切换至 0 号窗口，使用其他数字 id 切换至对应窗口 f 根据窗口名搜索选择窗口，可模糊匹配 会话操作如果运行了多次 tmux 命令则会开启多个 tmux 会话（session）。在 tmux 会话中，使用前缀快捷键 Ctrl+b 配合以下快捷键可操作会话： $ 重命名当前会话 s 选择会话列表 d detach 当前会话，运行后将会退出 tmux 进程，返回至 shell 主进程 shell命令 tmux new -s foo # 新建名称为 foo 的会话 tmux ls # 列出所有 tmux 会话 tmux a # 恢复至上一次的会话 tmux a -t foo # 恢复名称为 foo 的会话，会话默认名称为数字 tmux kill-session -t foo # 删除名称为 foo 的会话 tmux kill-server # 删除所有的会话]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh常用操作]]></title>
    <url>%2F2018%2F11%2F28%2Fssh%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[操作举例公钥复制到远程主机$ ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub 单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。 将$HOME/src/目录下面的所有文件，复制到远程主机的$HOME/src/目录。$ cd &amp;&amp; tar czv src | ssh user@host &#39;tar xz&#39; 将远程主机$HOME/src/目录下面的所有文件，复制到用户的当前目录。$ ssh user@host &#39;tar cz src&#39; | tar xzv 查看远程主机是否运行进程httpd。 $ ssh user@host &#39;ps ax | grep [h]ttpd&#39; 绑定本地端口既然SSH可以传送数据，那么我们可以让那些不加密的网络连接，全部改走SSH连接，从而提高安全性。 假定我们要让8080端口的数据，都通过SSH传向远程主机，命令就这样写： $ ssh -D 8080 user@host SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。 本地端口转发有时，绑定本地端口还不够，还必须指定数据传送的目标主机，从而形成点对点的”端口转发”。为了区别后文的”远程端口转发”，我们把这种情况称为”本地端口转发”（Local forwarding）。 假定host1是本地主机，host2是远程主机。由于种种原因，这两台主机之间无法连通。但是，另外还有一台host3，可以同时连通前面两台主机。因此，很自然的想法就是，通过host3，将host1连上host2。 我们在host1执行下面的命令： $ ssh -L 2121:host2:21 host3 命令中的L参数一共接受三个值，分别是”本地端口:目标主机:目标主机端口”，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。 这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。 $ ftp localhost:2121 “本地端口转发”使得host1和host3之间仿佛形成一个数据传输的秘密隧道，因此又被称为”SSH隧道”。 下面是一个比较有趣的例子。 $ ssh -L 5900:localhost:5900 host3 它表示将本机的5900端口绑定host3的5900端口（这里的localhost指的是host3，因为目标主机是相对host3而言的）。 另一个例子是通过host3的端口转发，ssh登录host2。 $ ssh -L 9001:host2:22 host3 这时，只要ssh登录本机的9001端口，就相当于登录host2了。 $ ssh -p 9001 localhost 上面的-p参数表示指定登录端口。 远程端口转发既然”本地端口转发”是指绑定本地端口的转发，那么”远程端口转发”（remote forwarding）当然是指绑定远程端口的转发。 还是接着看上面那个例子，host1与host2之间无法连通，必须借助host3转发。但是，特殊情况出现了，host3是一台内网机器，它可以连接外网的host1，但是反过来就不行，外网的host1连不上内网的host3。这时，”本地端口转发”就不能用了，怎么办？ 解决办法是，既然host3可以连host1，那么就从host3上建立与host1的SSH连接，然后在host1上使用这条连接就可以了。 我们在host3执行下面的命令： $ ssh -R 2121:host2:21 host1 R参数也是接受三个值，分别是”远程主机端口:目标主机:目标主机端口”。这条命令的意思，就是让host1监听它自己的2121端口，然后将所有数据经由host3，转发到host2的21端口。由于对于host3来说，host1是远程主机，所以这种情况就被称为”远程端口绑定”。 绑定之后，我们在host1就可以连接host2了： $ ftp localhost:2121 这里必须指出，”远程端口转发”的前提条件是，host1和host3两台主机都有sshD和ssh客户端。 SSH的其他参数SSH还有一些别的参数，也值得介绍。 N参数，表示只连接远程主机，不打开远程shell；T参数，表示不为这个连接分配TTY。这个两个参数可以放在一起用，代表这个SSH连接只用来传数据，不执行远程操作。 $ ssh -NT -D 8080 host f参数，表示SSH连接成功后，转入后台运行。这样一来，你就可以在不中断SSH连接的情况下，在本地shell中执行其他操作。 $ ssh -f -D 8080 host 要关闭这个后台连接，就只有用kill命令去杀掉进程。 进行X11转发 $ ssh -X user@host 参考链接SSH原理与运用（二）：远程操作与端口转发 - 阮一峰的网络日志]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X86和X87汇编指令大全]]></title>
    <url>%2F2018%2F11%2F22%2FX86%E5%92%8CX87%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285---------- 一、数据传输指令 ----------------------------------------------------它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.1. 通用数据传送指令. MOV 传送字或字节. MOVSX 先符号扩展,再传送. MOVZX 先零扩展,再传送. PUSH 把字压入堆栈. POP 把字弹出堆栈. PUSHA 把AX,CX,DX,BX,SP,BP,SI,DI依次压入堆栈. POPA 把DI,SI,BP,SP,BX,DX,CX,AX依次弹出堆栈. PUSHAD 把EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI依次压入堆栈. POPAD 把EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX依次弹出堆栈. BSWAP 交换32位寄存器里字节的顺序 XCHG 交换字或字节.(至少有一个操作数为寄存器,段寄存器不可作为操作数) CMPXCHG 比较并交换操作数.(第二个操作数必须为累加器AL/AX/EAX) XADD 先交换再累加.(结果在第一个操作数里) XLAT 字节查表转换.----BX指向一张256字节的表的起点,AL为表的索引值(0-255,即0-FFH);返回AL为查表结果.([BX+AL]-&gt;AL)2. 输入输出端口传送指令. IN I/O端口输入. ( 语法: IN 累加器, &#123;端口号│DX&#125; ) OUT I/O端口输出. ( 语法: OUT &#123;端口号│DX&#125;,累加器 )输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,其范围是 0-65535.3. 目的地址传送指令. LEA 装入有效地址.例: LEA DX,string ;把偏移地址存到DX. LDS 传送目标指针,把指针内容装入DS.例: LDS SI,string ;把段地址:偏移地址存到DS:SI. LES 传送目标指针,把指针内容装入ES.例: LES DI,string ;把段地址:偏移地址存到ES:DI. LFS 传送目标指针,把指针内容装入FS.例: LFS DI,string ;把段地址:偏移地址存到FS:DI. LGS 传送目标指针,把指针内容装入GS.例: LGS DI,string ;把段地址:偏移地址存到GS:DI. LSS 传送目标指针,把指针内容装入SS.例: LSS DI,string ;把段地址:偏移地址存到SS:DI.4. 标志传送指令. LAHF 标志寄存器传送,把标志装入AH. SAHF 标志寄存器传送,把AH内容装入标志寄存器. PUSHF 标志入栈. POPF 标志出栈. PUSHD 32位标志入栈. POPD 32位标志出栈.---------- 二、算术运算指令 ---------------------------------------------------- ADD 加法. ADC 带进位加法. INC 加 1. AAA 加法的ASCII码调整. DAA 加法的十进制调整. SUB 减法. SBB 带借位减法. DEC 减 1. NEG 求反(以 0 减之). CMP 比较.(两操作数作减法,仅修改标志位,不回送结果). AAS 减法的ASCII码调整. DAS 减法的十进制调整. MUL 无符号乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), IMUL 整数乘法.结果回送AH和AL(字节运算),或DX和AX(字运算), AAM 乘法的ASCII码调整. DIV 无符号除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). IDIV 整数除法.结果回送:商回送AL,余数回送AH, (字节运算);或 商回送AX,余数回送DX, (字运算). AAD 除法的ASCII码调整. CBW 字节转换为字. (把AL中字节的符号扩展到AH中去) CWD 字转换为双字. (把AX中的字的符号扩展到DX中去) CWDE 字转换为双字. (把AX中的字符号扩展到EAX中去) CDQ 双字扩展. (把EAX中的字的符号扩展到EDX中去)---------- 三、逻辑运算指令 ---------------------------------------------------- AND 与运算. OR 或运算. XOR 异或运算. NOT 取反. TEST 测试.(两操作数作与运算,仅修改标志位,不回送结果). SHL 逻辑左移. SAL 算术左移.(=SHL) SHR 逻辑右移. SAR 算术右移.(=SHR) ROL 循环左移. ROR 循环右移. RCL 通过进位的循环左移. RCR 通过进位的循环右移. 以上八种移位指令,其移位次数可达255次. 移位一次时, 可直接用操作码. 如 SHL AX,1. 移位&gt;1次时, 则由寄存器CL给出移位次数. 如 MOV CL,04 SHL AX,CL---------- 四、串指令 ---------------------------------------------------------- DS:SI 源串段寄存器 :源串变址. ES:DI 目标串段寄存器:目标串变址. CX 重复次数计数器. AL/AX 扫描值. D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量. Z标志 用来控制扫描或比较操作的结束. MOVS 串传送.( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. ) CMPS 串比较.( CMPSB 比较字符. CMPSW 比较字. ) SCAS 串扫描.把AL或AX的内容与目标串作比较,比较结果反映在标志位. LODS 装入串.把源串中的元素(字或字节)逐一装入AL或AX中.( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. ) STOS 保存串.是LODS的逆过程. REP 当CX/ECX&lt;&gt;0时重复. REPE/REPZ 当ZF=1或比较结果相等,且CX/ECX&lt;&gt;0时重复. REPNE/REPNZ 当ZF=0或比较结果不相等,且CX/ECX&lt;&gt;0时重复. REPC 当CF=1且CX/ECX&lt;&gt;0时重复. REPNC 当CF=0且CX/ECX&lt;&gt;0时重复.---------- 五、程序转移指令 ----------------------------------------------------1. 无条件转移指令 (长转移) JMP 无条件转移指令 CALL 过程调用 RET/RETF 过程返回.2. 条件转移指令 (短转移,-128到+127的距离内)( 当且仅当(SF XOR OF)=1时,OP1&lt;OP2 ) JA/JNBE 不小于或不等于时转移. JAE/JNB 大于或等于转移. JB/JNAE 小于转移. JBE/JNA 小于或等于转移. 以上四条,测试无符号整数运算的结果(标志C和Z). JG/JNLE 大于转移. JGE/JNL 大于或等于转移. JL/JNGE 小于转移. JLE/JNG 小于或等于转移. 以上四条,测试带符号整数运算的结果(标志S,O和Z). JE/JZ 等于转移. JNE/JNZ 不等于时转移. JC 有进位时转移. JNC 无进位时转移. JNO 不溢出时转移. JNP/JPO 奇偶性为奇数时转移. JNS 符号位为 &quot;0&quot; 时转移. JO 溢出转移. JP/JPE 奇偶性为偶数时转移. JS 符号位为 &quot;1&quot; 时转移.3. 循环控制指令(短转移) LOOP CX不为零时循环. LOOPE/LOOPZ CX不为零且标志Z=1时循环. LOOPNE/LOOPNZ CX不为零且标志Z=0时循环. JCXZ CX为零时转移. JECXZ ECX为零时转移.4. 中断指令 INT 中断指令 INTO 溢出中断 IRET 中断返回5. 处理器控制指令 HLT 处理器暂停, 直到出现中断或复位信号才继续. WAIT 当芯片引线TEST为高电平时使CPU进入等待状态. ESC 转换到外处理器. LOCK 封锁总线. NOP 空操作. STC 置进位标志位. CLC 清进位标志位. CMC 进位标志取反. STD 置方向标志位. CLD 清方向标志位. STI 置中断允许位. CLI 清中断允许位.---------- 六、伪指令 ---------------------------------------------------------- DW 定义字(2字节). PROC 定义过程. ENDP 过程结束. SEGMENT 定义段. ASSUME 建立段寄存器寻址. ENDS 段结束. END 程序结束.---------- 七、处理机控制指令：标志处理指令 ------------------------------------ CLC 进位位置0指令 CMC 进位位求反指令 STC 进位位置为1指令 CLD 方向标志置1指令 STD 方向标志位置1指令 CLI 中断标志置0指令 STI 中断标志置1指令 NOP 无操作 HLT 停机 WAIT 等待 ESC 换码 LOCK 封锁========== 浮点运算指令集 ======================================================---------- 一、控制指令(带9B的控制指令前缀F变为FN时浮点不检查，机器码去掉9B)----FINIT 初始化浮点部件 机器码 9B DB E3FCLEX 清除异常 机器码 9B DB E2FDISI 浮点检查禁止中断 机器码 9B DB E1FENI 浮点检查禁止中断二 机器码 9B DB E0WAIT 同步CPU和FPU 机器码 9BFWAIT 同步CPU和FPU 机器码 D9 D0FNOP 无操作 机器码 DA E9FXCH 交换ST(0)和ST(1) 机器码 D9 C9FXCH ST(i) 交换ST(0)和ST(i) 机器码 D9 C1iiiFSTSW ax 状态字到ax 机器码 9B DF E0FSTSW word ptr mem 状态字到mem 机器码 9B DD mm111mmmFLDCW word ptr mem mem到状态字 机器码 D9 mm101mmmFSTCW word ptr mem 控制字到mem 机器码 9B D9 mm111mmmFLDENV word ptr mem mem到全环境 机器码 D9 mm100mmmFSTENV word ptr mem 全环境到mem 机器码 9B D9 mm110mmmFRSTOR word ptr mem mem到FPU状态 机器码 DD mm100mmmFSAVE word ptr mem FPU状态到mem 机器码 9B DD mm110mmmFFREE ST(i) 标志ST(i)未使用 机器码 DD C0iiiFDECSTP 减少栈指针1-&gt;0 2-&gt;1 机器码 D9 F6FINCSTP 增加栈指针0-&gt;1 1-&gt;2 机器码 D9 F7FSETPM 浮点设置保护 机器码 DB E4---------- 二、数据传送指令 ----------------------------------------------------FLDZ 将0.0装入ST(0) 机器码 D9 EEFLD1 将1.0装入ST(0) 机器码 D9 E8FLDPI 将π装入ST(0) 机器码 D9 EBFLDL2T 将ln10/ln2装入ST(0) 机器码 D9 E9FLDL2E 将1/ln2装入ST(0) 机器码 D9 EAFLDLG2 将ln2/ln10装入ST(0) 机器码 D9 ECFLDLN2 将ln2装入ST(0) 机器码 D9 EDFLD real4 ptr mem 装入mem的单精度浮点数 机器码 D9 mm000mmmFLD real8 ptr mem 装入mem的双精度浮点数 机器码 DD mm000mmmFLD real10 ptr mem 装入mem的十字节浮点数 机器码 DB mm101mmmFILD word ptr mem 装入mem的二字节整数 机器码 DF mm000mmmFILD dword ptr mem 装入mem的四字节整数 机器码 DB mm000mmmFILD qword ptr mem 装入mem的八字节整数 机器码 DF mm101mmmFBLD tbyte ptr mem 装入mem的十字节BCD数 机器码 DF mm100mmmFST real4 ptr mem 保存单精度浮点数到mem 机器码 D9 mm010mmmFST real8 ptr mem 保存双精度浮点数到mem 机器码 DD mm010mmmFIST word ptr mem 保存二字节整数到mem 机器码 DF mm010mmmFIST dword ptr mem 保存四字节整数到mem 机器码 DB mm010mmmFSTP real4 ptr mem 保存单精度浮点数到mem并出栈 机器码 D9 mm011mmmFSTP real8 ptr mem 保存双精度浮点数到mem并出栈 机器码 DD mm011mmmFSTP real10 ptr mem 保存十字节浮点数到mem并出栈 机器码 DB mm111mmmFISTP word ptr mem 保存二字节整数到mem并出栈 机器码 DF mm011mmmFISTP dword ptr mem 保存四字节整数到mem并出栈 机器码 DB mm011mmmFISTP qword ptr mem 保存八字节整数到mem并出栈 机器码 DF mm111mmmFBSTP tbyte ptr mem 保存十字节BCD数到mem并出栈 机器码 DF mm110mmmFCMOVB ST(0),ST(i) &lt;时传送 机器码 DA C0iiiFCMOVBE ST(0),ST(i) &lt;=时传送 机器码 DA D0iiiFCMOVE ST(0),ST(i) =时传送 机器码 DA C1iiiFCMOVNB ST(0),ST(i) &gt;=时传送 机器码 DB C0iiiFCMOVNBE ST(0),ST(i) &gt;时传送 机器码 DB D0iiiFCMOVNE ST(0),ST(i) !=时传送 机器码 DB C1iiiFCMOVNU ST(0),ST(i) 有序时传送 机器码 DB D1iiiFCMOVU ST(0),ST(i) 无序时传送 机器码 DA D1iii---------- 三、比较指令 --------------------------------------------------------FCOM ST(0)-ST(1) 机器码 D8 D1FCOMI ST(0),ST(i) ST(0)-ST(1) 机器码 DB F0iiiFCOMIP ST(0),ST(i) ST(0)-ST(1)并出栈 机器码 DF F0iiiFCOM real4 ptr mem ST(0)-实数mem 机器码 D8 mm010mmmFCOM real8 ptr mem ST(0)-实数mem 机器码 DC mm010mmmFICOM word ptr mem ST(0)-整数mem 机器码 DE mm010mmmFICOM dword ptr mem ST(0)-整数mem 机器码 DA mm010mmmFICOMP word ptr mem ST(0)-整数mem并出栈 机器码 DE mm011mmmFICOMP dword ptr mem ST(0)-整数mem并出栈 机器码 DA mm011mmmFTST ST(0)-0 机器码 D9 E4FUCOM ST(i) ST(0)-ST(i) 机器码 DD E0iiiFUCOMP ST(i) ST(0)-ST(i)并出栈 机器码 DD E1iiiFUCOMPP ST(0)-ST(1)并二次出栈 机器码 DA E9FXAM ST(0)规格类型 机器码 D9 E5---------- 四、运算指令 --------------------------------------------------------FADD 把目的操作数 (直接接在指令后的变量或堆栈缓存器) 与来源操作数 (接在目的操作数后的变量或堆栈缓存器) 相加，并将结果存入目的操作数FADDP ST(i),ST 这个指令是使目的操作数加上 ST 缓存器，并弹出 ST 缓存器，而目的操作数必须是堆栈缓存器的其中之一，最后不管目的操作数为何，经弹出一次后，目的操作数会变成上一个堆栈缓存器了FIADD FIADD 是把 ST 加上来源操作数，然后再存入 ST 缓存器，来源操作数必须是字组整数或短整数形态的变数FSUB 减FSUBPFSUBR 减数与被减数互换FSUBRPFISUBFISUBRFMUL 乘FMULPFIMULFDIV 除FDIVPFDIVRFDIVRPFIDIVFIDIVRFCHS 改变 ST 的正负值FABS 把 ST 之值取出，取其绝对值后再存回去。FSQRT 将 ST 之值取出，开根号后再存回去。FSCALE 这个指令是计算 ST*2^ST(1)之值，再把结果存入 ST 里而 ST(1) 之值不变。ST(1) 必须是在 -32768 到 32768 (-215 到 215 )之间的整数，如果超过这个范围计算结果无法确定，如果不是整数 ST(1) 会先向零舍入成整数再计算。所以为安全起见，最好是由字组整数载入到 ST(1) 里。FRNDINT 这个指令是把 ST 的数值舍入成整数，FPU 提供四种舍入方式，由 FPU 的控制字组(control word)中的 RC 两个位决定 RC 舍入控制 00 四舍五入 01 向负无限大舍入 10 向正无限大舍入 11 向零舍去================================================================================]]></content>
      <tags>
        <tag>编程</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机系统结构(四)——并行I/O结构及操作]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84(%E5%9B%9B)-%E5%B9%B6%E8%A1%8CI-O%E7%BB%93%E6%9E%84%E5%8F%8A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[8051共有4个8位I/O口，共32口线。每位均有自己的锁存器(SFR)，输出驱动器和输入缓冲器。 P0口的结构与操作控制信号为0时，P0口做一般I/O口。控制信号为1时，P0口为地址/数据复用总线。 P0口做一般I/O口使用 数据输出写脉冲加在C上 若D=0，则$\bar Q$=1，则下拉FET导通，P00引脚输出0 若D=1，则$\bar Q$=0，则下拉FET截止，P00引脚高阻 注意：P0口作为一般I/O口时，要外接上拉电阻，以避免数据输出时，出现三态。 数据输入 直接读端口引脚处的数据 由下面的三态缓冲器将端口数据送入内部总线 读锁存器Q端的数据 由上面的三态缓冲器将端口数据送入内部总线 读端口引脚处的数据与读锁存器处的数据的区别 读锁存器的数据为了避免读错引脚上的电平 读锁存器的数据为了适应“读-修改-写”类指令 “读-修改-写”类指令 指令的特点先读口（锁存器Q端）对读入的数据进行修改再把修改后的数据写到端口上 规律当目的操作数为I/O口或其中的某一位时，均为“读-修改-写”类指令，要从锁存器中读取数据当源操作数为I/O口或其中的某一位时，要直接读引脚处数据 P0作为一般输入输出接口时是一个准双向口 原因前一时刻，如果输出数据0，则Q=1，下拉FET导通，P00=0下一时刻，要输入数据，由于下拉FET处于开通状态，数据不可能被正确输入，因而是一个准双向口 解决办法输入数据前，先把该口置1，使下拉FET截止，以便数据能正确输入 P0口作为地址/数据总线控制信号为高电平1，转换开关接至反向器输出端，同时与门开锁 输入数据时，与作为一般I/O使用时相同，应先向该口置1（系统自动完成）P0输出地址或数据时 若输出1，则上面FET开通、下面FET关断，P0.0=1 若输出0，则下面FET开通、上面FET关断，P0.0=0注意： P0作为数据/地址总线复用，输出数据时，不需外接上拉电阻 P1口的结构与操作 输出部分有内部上拉电阻R*约为20K，输出数据时不必外加上拉电阻其他部分与P0端口使用相类似，也是一个准双向口 P2口的结构与操作控制信号为0时，P2口做一般I/O口。控制信号为1时，P2口为高8位地址输出。当P2口作为普通I/O口使用时，用法和P1口类似。P2口输出地址信息时，此时单片机完成取指操作或对外部数据存储器16位地址的读写操作。 P3口的结构与操作做普通端口使用时，变异功能应为“1”使用第二功能时，输出端口锁存器应为“1” P3口第二功能 引脚 转义引脚 功能说明 P3.0 RXD 串行数据接收端 P3.1 TXD 串行数据发送端 P3.2 INT0 外部中断0请求 P3.3 INT1 外部中断1请求 P3.4 T0 计数器0外部输入 P3.5 T1 计数器1外部输入 P3.6 WR 外部数据存储器写 P3.7 RD 外部数据存储器读 其它说明 I/O性质的另一观点 P0为三态双向I/O 因当要输入数据时，先给P0锁存器置1，这时场效应管关断，该口线成为高阻状态，故称P0为三态双向口。 P1~P3为准双向口 因当要输入数据时，先给P1~P3锁存器置1，这时场效应管关断，但由于P1~P3内部均有上拉电阻，该口线被拉成高电平，故称P1~P3为准双向口。 I/O的输出负载能力 P0口的每一位输出可以驱动8个LS TTL输入。 P1~P3口的每一位输出可以驱动4个LS TTL输入。负载能力产生的原因： 如果各口线内部输出驱动电路中的电流过大，可能导致输出信号电平的紊乱。]]></content>
      <tags>
        <tag>单片机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机系统结构(三)——时钟电路]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%B8%89-%E2%80%94%E2%80%94%E6%97%B6%E9%92%9F%E7%94%B5%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[MCS-51内部时钟电路（CHMOS型）内部有一个用于构成振荡器的高增益反向放大器，引脚XTAL1和XTAL2分别是此放大器的输入端和输出端。PD为电源控制寄存器中的一位，PD=1时，可切断振荡器工作，使系统进入低功耗工作状态。 石英晶体振荡电路将石英晶体、C1、C2作为反馈元件，与内部放大器一起构成一个自激振荡器，其发出的脉冲直接送入内部时钟。 石英晶体的特性 当信号频率为$f_0$时，石英晶体的阻抗最小，信号最易通过 振荡频率只取决于谐振频率$f_0$，一般为$1.2MHz~12MHz$ 电容参数 C1和C2一般取30±10PF，电容的大小会略微影响振荡频率及振荡的稳定性 在设计印刷线路板时，应使晶体和电容尽可能离单片机近些，以减少寄生电容 外部时钟源接法 不同类型的单片机，外部振荡源信号可能接入X2，要参考单片机具体内部电路或手册对外部信号的占空比没有什么要求，但要求最小高电平和低电平持续时间应符合产品技术条件的要求（20ns) CPU时序时序是非常重要的概念，它指明单片机内部及内部与外部相互联系所遵循的规律 振荡周期为单片机提供定时信号的振荡源的周期 状态周期（时钟周期或S周期）是振荡周期的2倍，每个时钟周期被分为2个节拍，即P1、P2 在每个时钟周期的前半周期，P1信号有效，这时通常完成算术、逻辑操作 在每个时钟周期的后半周期，P2信号有效，内部寄存器与寄存器之间的传输一般发生在此状态 机器周期一个机器周期由六个时钟周期组成，机器周期是指令执行时间的基本单位 指令周期执行一条指令所需的全部时间，一个指令周期通常包含1、2、4个机器周期 指令长度（1~3字节）与指令周期的关系单字节、双字节指令可能是单周期或双周期的3字节指令都为双周期乘除法指令为4周期 复位与复位电路复位是使CPU和系统中其它部件处于一个确定的初始状态，并从这个状态开始工作RST引脚上出现2个周期的高电平时，单片机复位 单片机的复位状态 寄存器 值 PC 0000H ACC 00H B 00H PSW 00H SP 07H DPTR 0000H P0 0FFH IP XX000000 IE 0X000000 TMOD 00H TCON 00H TH0 00H TL0 00H TH1 00H TL1 00H SCON 00H SBUF XXH PCON X0000 复位电路 上电复位电路 开关复位电路]]></content>
      <tags>
        <tag>单片机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rime指定程序不输入中文]]></title>
    <url>%2F2018%2F04%2F05%2Frime%E6%8C%87%E5%AE%9A%E7%A8%8B%E5%BA%8F%E4%B8%8D%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[如在winkawaks.exe中不输入中文则如此设定： # squirrel.custom.yaml patch: app_options/winkawaks.exe: ascii_mode: true]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome浏览器离线安装包下载地址]]></title>
    <url>%2F2018%2F04%2F05%2FChrome%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[最新稳定版最新测试版最新开发版]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu&debian fcitx输入模块]]></title>
    <url>%2F2018%2F04%2F05%2Fubuntu-debian-fcitx%E8%BE%93%E5%85%A5%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[fcitx：fcitx主程序 fcitx-sogoupinyin ：fcitx的搜狗拼音词库。（你也可以换成其他类型的词库比如五笔、rime等等，具体可以终端输入aptitude search fcitx搜索。） fcitx-config-gtk：fcitx的gtk的设置图形界面。 fcitx-frontend-all：fcitx在所有环境下的前端。（有qt、gtk2、gtk3下对应的包组成。） fcitx-module-cloudpinyin：fcitx的云拼音模块。 fcitx-ui-classic：fcitx的经典UI显示模块。（此软件包不能被fcitx-ui-light或者fcitx-ui-qimpanel代替，因为该包默认包含着fcitx-module-x11，有了它才能在让fcitx在图形界面上显示出输入框。） KDE用户还可以安装fcitx的QT化组件来使fcitx风格能更加与KDE桌面环境统一：sudo aptitude install fcitx-ui-qimpanel fcitx-module-kimpanel plasma-widget-kimpanels]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux目录结构&文件类型]]></title>
    <url>%2F2018%2F04%2F05%2FLinux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%26%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[目录结构 文件类型链接文件（link）就是类似Windows系统下面的捷径啦！ 第一个属性为 [ l ]（英文L的小写），例如 [lrwxrwxrwx] 设备与设备文件（device）与系统周边及储存等相关的一些文件， 通常都集中在/dev这个目录之下！通常又分为两种： 区块（block）设备文件就是一些储存数据， 以提供系统随机存取的周边设备，举例来说，硬盘与软盘等就是啦！ 你可以随机的在硬盘的不同区块读写，这种设备就是区块设备啰！你可以自行查一下/dev/sda看看， 会发现第一个属性为[ b ]喔！ 字符（character）设备文件亦即是一些序列埠的周边设备， 例如键盘、鼠标等等！这些设备的特色就是“一次性读取”的，不能够截断输出。 举例来说，你不可能让鼠标“跳到”另一个画面，而是“连续性滑动”到另一个地方啊！第一个属性为 [ c ]。 数据接口文件（sockets）既然被称为数据接口文件， 想当然尔，这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听用户端的要求， 而用户端就可以通过这个socket来进行数据的沟通了。第一个属性为[ s ]， 最常在/run或/tmp这些个目录中看到这种文件类型了。 数据输送档（FIFO, pipe）FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为[ p ] 。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux和windows双系统时间不一致问题]]></title>
    <url>%2F2018%2F04%2F05%2Flinux%E5%92%8Cwindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[硬件时钟使用 UTC推荐使用这种方法，参考archwiki页面#Windows_.E7.B3.BB.E7.BB.9F.E4.BD.BF.E7.94.A8_UTC) 代码:timedatectl set-local-rtc 0 timedatectl set-ntp 1 修改 Windows 注册表：代码:Reg add HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 关闭 Windows 网络对时时 硬件时钟使用本地时间 设置linux使用本地时间代码:timedatectl set-local-rtc 1timedatectl set-ntp 0 打开 Windows 网络对时]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#语言的类型系统]]></title>
    <url>%2F2018%2F04%2F05%2FC-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[类(classes):如Windows,Form,Console,String 结构体(structures):如int32,int64,single,double 枚举(enumerations):如HorizontalAlignment,Visibility 接口(interfaces) 委托(delegates)]]></content>
      <tags>
        <tag>编程</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notepad++与gcc搭建简易C&C++开发环境]]></title>
    <url>%2F2018%2F04%2F05%2FNotepad-%E4%B8%8Egcc%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93C-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[编译在notepad++中打开“运行”，输入以下代码并保存，可以自定义快捷键以及设置命令名cmd /k g++ $(FULL_CURRENT_PATH) -o $(CURRENT_DIRECTORY)\$(NAME_PART) &amp;PAUSE &amp;EXIT cmd /k 执行命令后不关闭命令窗口 cmd /c 执行命令并关闭命令窗口 $(CURRENT_DIRECTORY) 当前所在目录 $(FILE_NAME) 当前操作文件的文件名，包含后缀 $(NAME_PART) 当前操作文件的文件名，不包含后缀 $(FULL_CURRENT_PATH) 当前操作文件的完整路径，包括盘符，路径，文件名，后缀 &amp;PAUSE 运行后暂停等待键盘操作 &amp;EXIT 完成后退出运行窗口 执行输入以下命令并保存：cmd /k $(CURRENT_DIRECTORY)\$(NAME_PART) &amp;PAUSE &amp;EXIT]]></content>
      <tags>
        <tag>编程</tag>
        <tag>C语言</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代控制理论概述]]></title>
    <url>%2F2018%2F03%2F31%2F%E7%8E%B0%E4%BB%A3%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[现代控制理论特点 描述对象的方法 状态空间模型，适用于多输入多输出、时变、非线性系统。(MIMO system;Time-varying system; Nonlinear system) 处理方法 应用现代数学方法，以计算机作为工具，系统化的分析和综合方法。 实现多目标控制 预测控制、鲁棒控制、模糊控制等先进控制 课程主要内容 状态空间模型 (State space model) 基于状态空间模型的系统分析(Analysis) 运动分析、能控性、能观性、稳定性 (Motion analysis Controllability Observability Stability) 基于状态空间模型的系统综合(Synthesis) 状态反馈、输出反馈、极点配置、观测器设计 (State feedback Output feedback Pole placement Observer design) 控制系统的状态空间描述引言状态空间描述状态空间描述的状态变量图状态空间描述的建立化输入-输出描述为状态空间描述离散系统状态空间描述的建立线性变换由状态空间描述求传递函数阵线性系统的状态空间运动分析线性定常系统的齐次解矩阵指数函数线性定常系统的非齐次解线性定常系统的状态转移矩阵线性时变系统的运动线性连续系统的时间离散化线性离散系统的运动分析线性控制系统的能控性和能观测性能控性和能观测性的概念连续时间线性定常系统的能控性连续时间线性定常系统的能观测性离散时间线性定常系统的能控性和能观测性连续时间线性时变系统的能控性与能观测性线性系统能控性与能观测性的对偶关系能控标准形和能观测标准形传递函数中零极点对消与状态能控和能观测之间的关系线性系统结构按能控性、能观测性的分解控制系统的稳定性—Lyapunov第二方法关于稳定性的几个定义李亚普诺夫第一方法李亚普诺夫第二方法非线性系统的Lyapunov稳定性分析线性定常系统的Lyapunov稳定性分析Lyapunov第二方法在线性系统设计中的应用线性定常系统的综合状态反馈与极点配置输出反馈与极点配置控制系统的镇定问题状态重构与状态观测器的设计多变量系统的解耦控制]]></content>
      <tags>
        <tag>现代控制理论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看CPU温度]]></title>
    <url>%2F2018%2F03%2F29%2FLinux%E6%9F%A5%E7%9C%8BCPU%E6%B8%A9%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[需安装软件包 lm_sensors 检测传感器：$ sudo sh -c &quot;yes|sensors-detect&quot; 查看CPU温度$ sensors]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机系统结构(二)——存储器配置]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%BA%8C-%E2%80%94%E2%80%94%E5%AD%98%E5%82%A8%E5%99%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[物理上有四个存储空间逻辑上有三个存储空间 片内数据存储器 片内程序存储器片内数据存储器 片外数据存储器 64K 片外数据存储器 片外程序存储器片内外统一的程序存储器 64K 51子系列 52子系列 片内数据存储器 128B 256B 专用寄存器区 128B 128B 片内程序存储器 4K 8K 程序存储区存放编制好的程序或表格数据，只能读取 内外程序存储器的地址空间是统一的，共64K 若EA=1，则从内部ROM开始执行，超出内部ROM的容量时，再从外部ROM的1000H单元接着执行。（51子系列） 若EA=0，则直接从外部ROM取指执行 对程序存储器访问的寻址方式 立即数寻址 基址+变址寻址 程序存储器中的特殊单元 0000H 取指执行程序的起始单元，一般在该单元放一条绝对跳转指令，用户设计的主程序从跳转地址开始安放 0003H 外部中断0中断服务程序的入口地址 000BH 定时器0溢出中断中断服务程序的入口地址 0013H 外部中断1中断服务程序的入口地址 001BH 定时器1溢出中断中断服务程序的入口地址 0023H 串行口中断服务程序的入口地址 002BH 定时器2溢出中断中断服务程序的入口地址 片内数据存储器 片内数据存储区的编址 51子系列:低128字节RAM与SFR块相连 52子系列:高128字节RAM与SFR块逻辑地址重合 高128RAM：寄存器间接寻址 SFR：直接寻址 低128字节RAM的配置 通用寄存器区4组8个8位寄存器R0~R7由PSW中的RS1,RS0选择当前工作区 位寻址空间20H~2FH字节可以位寻址 字节寻址空间30H~7FH字节(80B) 堆栈堆栈设置在内部数据存储区堆栈的位置不固定，可以通过一个专用寄存器SP（栈指针）来设定栈顶的位置数据入栈时，栈指针递增堆栈深度最大为128B 专用寄存器 标识符 名 称 地址 *ACC 累加器 E0H *B B寄存器 F0H *PSW 程序状态字 D0H SP 堆栈指针 81H DPTR 数据指针(DPH和DPL) 82H,83H *P0 口0 80H *P1 口1 90H *P2 口2 A0H *P3 口3 B0H *IP 中断优先级寄存器 B8H *IE 中断控制寄存器 A8H TMOD 定时器方式寄存器 89H *TCON 定时器控制寄存器 88H TH0 计数器0高位 8CH TL0 计数器0低位 8AH TH1 计数器1高位 8DH TL1 计数器1低位 8BH *SCON 串行口控制 98H SBUF 串行数据缓冲器 99H PCON 电源控制 97H 51子系列有19个专用寄存器 52子系列有22个专用寄存器 双字节寄存器6个，其中PC在物理上独立，所以专用寄存器在SFR区占26字节 *表示 可以位寻址的寄存器 （其地址可被8整除） 程序计数器PC用于存放下一条要执行指令的地址是一个16位专用寄存器，寻址范围为0~65535 （64K）PC在物理上是独立的，不属于内部数据存储器的SFR 累加器A（Acc）最常用的一个专用寄存器大部分单操作数指令的操作数取自累加器很多双操作数指令的一个操作数取自累加器加、减、乘、除运算指令的结果都存放在A或AB中 B寄存器在乘、除法指令中用到B寄存器乘法：两个操作数分别取自A和B，结果存放于AB中除法：被除数在A中、除数在B中，商在A、余数在B中其它指令中，B可作为RAM的一个单元用 程序状态字寄存器PSW — 保存指令执行状态 D7 D6 D5 D4 D3 D2 D1 D0 Cy AC F0 RS1 RS0 OV - P Cy：进位标志保存算术运算的进或借位位操作的累加器 AC：辅助进位标志加法或减法运算产生从D3向D4进位或借位时，AC=1常用于十进制调整指令 F0：标志0，用户定义的一个状态标记 RS1, RS0：通用寄存器组选择 0 0 寄存器组0(00H~07H） 0 1 寄存器组1(08H~0FH） 1 0 寄存器组2(10H~17H） 1 1 寄存器组3(18H~1FH） OV：溢出标志位 当执行算术指令时，由硬件置位或清除，以指示溢出状态。 执行加法操作时，以$C’_i$表示第i位向第i+1位有进位，则 $$OV=C’_6 ⊕ C’_7 $$溢出标志可以判断带符号数相加时，和数是否溢出，即大于127或小于-128 对于减法操作，以$C’_i$表示第i位向第i+1位有借位，则$$OV= C’_6 ⊕ C’_7$$ 对于乘法操作，若两数乘积大于255时，则OV=1 对于除法，当除数为0时，OV=1 P：奇偶标志位 每个机器周期根据累加器A中的内容的奇偶性由硬件置/复位 A中1的个数为奇P=1，否则为P=0 该位对串行通讯的数据传输有重要意义，可以借助该位进行奇偶校验 栈指针SP SP为8位寄存器，指示栈顶位置 系统复位后，SP初始值为07H，最好将其设为1FH或更大 进栈：SP+1，再压栈 出栈：先出栈，再SP-1改变SP的途径 软件直接改变 执行PUSH或POP指令 子程序调用、返回 中断响应与返回 数据指针DPTR DPTR是16位寄存器，也可作为两个独立的8位寄存器DPL、DPH使用 主要用于保存16位地址，可以寻址64K地址空间 当访问外部数据存储器时，可作为间址寄存器 MOVX A , @DPTR MOVX @DPTR , A 当访问程序存储器时，可作为基址寄存器 MOVC A , @A+DPTR 串行口数据缓冲器SBUF 用于存放欲发送或已接受的数据 包含两个独立的寄存器：发送缓冲器、接收缓冲器 定时器/计数器 T0、T1、T2为三个16位寄存器，各由2个8位寄存器组成：TH0、TL0、TH1、TL1、TH2、TL2 系统可以对TH0、TL0、TH1、TL1、TH2、TL2进行寻址 不能把T0、T1、T2作为16位寄存器使用 端口P0~P3 由端口硬件结构，P0~P3都有相应的锁存器，因而P0~P3可作为专用寄存器使用 由于可以把P0~P3当作寄存器使用，因而不再设口操作指令，都用MOV 其它常用寄存器 IP：中断优先级寄存器 IE：允许中断寄存器 TMOD：定时器模式选择寄存器 TCON：定时器控制寄存器 SCON：串行口控制寄存器 PCON：电源控制寄存器 外部数据存储器寻址空间：64K采用间接寻址方式访问，间址寄存器为R0、R1和DPTR 布尔处理机]]></content>
      <tags>
        <tag>单片机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机系统结构(一)——引脚描述]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-%E4%B8%80-%E2%80%94%E2%80%94%E5%BC%95%E8%84%9A%E6%8F%8F%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[引脚逻辑图 8051单片机为40条引脚双列直插式封装 引脚可分为三个部分 引脚描述电源引脚VCC——+5VGND——接地 时钟引脚 X1（ XTAL1 ）连接片内部振荡器的输入端外接晶体时，它外接石英晶体的一端采用外部脉冲振荡器时，此引脚为驱动端 X2（ XTAL2）连接片内部振荡器输出端外接晶体时，它外接石英晶体的另一端采用外部脉冲振荡器时，此引脚空 控制引脚 $RST/V_{PD}$——复位信号振荡器工作时，此引脚 2 个机器周期的高电平复位CPU掉电期间，若该引脚接备用电源，可保证RAM中数据不丢失 $ALE/\overline{PROG}$——地址锁存信号访问外部存储器时，锁存低 8 位地址无外部RAM时，ALE输出晶振 6分频脉冲对EEPROM编程时，用于输入编程脉冲 $\overline{EA}/ VPP$——允许访问片内外程序 存储器控制端 EA=1，从内部程序存储器开始执行程序 EA=0，只访问外程序存储器对EEPROM编程时，VPP用于加21V的编程电源 $\overline{PSEN}$ ——外部程序存储器读从程序存储器中取指令或读取数据时，该信号有效 并行I/O口引脚 P0口 8位漏级开路准双向I/O口 使用外存时，分时复用地址(低8位)/数据总线 能以吸收电流的方式驱动8个LS TTL输入 P1口 带内部上拉电阻的8位准双向I/O口 能驱动4个LS TTL输入 P2口 带内部上拉电阻的8位准双向I/O口 访问外存时，只输出地址高8位 能驱动4个LS TTL输入 P3口 带内部上拉电阻的8位准双向I/O口 能驱动4个LS TTL输入 每位口线还具有第二功能 P3口第二功能 引脚 转义引脚 功能说明 P3.0 RXD 串行数据接收端 P3.1 TXD 串行数据发送端 P3.2 INT0 外部中断0请求 P3.3 INT1 外部中断1请求 P3.4 T0 计数器0外部输入 P3.5 T1 计数器1外部输入 P3.6 WR 外部数据存储器写 P3.7 RD 外部数据存储器读]]></content>
      <tags>
        <tag>单片机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单片机原理概述]]></title>
    <url>%2F2018%2F03%2F29%2F%E5%8D%95%E7%89%87%E6%9C%BA%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[教学内容 第二章 单片机系统结构 引脚描述 串行口 时钟系统 存储器配置 定时器/计数器 并行I/O口中断系统 第三章 指令系统 指令 伪指令 汇编程序设计 第四章 单片机系统扩展与应用 存储器扩展 总线扩展 显示器及接口 键盘及接口 中断服务程序设计与应用 综合应用 INTEL单片机简介 MCS-48系列单片机 | 产品系列 | ROM | EPROM | 无ROM | ROM | RAM| | - | - | - | - | - | - | - | | 48 |8048| 8748| 8035| 1KB | 64B | | 49 |8049| 8749| 8039| 2KB | 128B | | 50 |8050| 8750| 8040| 4KB |256B | 主要特征 8位CPU； 27根I/O口线； 4~11MHZ外部晶振，内部有时钟电路； 1个8位定时计数器； 单级中断系统，2个中断源； 96条指令，其中70%指令为单字节指令，50%以上指令执行时间为一个机器周期。 MCS-51系列单片机 | 产品系列 | ROM | EPROM | 无ROM | ROM | RAM | - | - | - | - | - | - | | 51 | 8051 | 8751 | 8031 | 4KB | 128B | | 52 | 8052 | 8752 | 8032 | 8KB | 256B | | 44 | 8044 | 8744 | 8344 | 4KB | 192B | 主要特征 8位CPU； 32条I/O口线； 1~12MHZ晶振，内部有时钟电路； 2个（3个）16位定时/计数器； 2个优先级，5个（6个）中断源； 1个全双工串行I/O口； 1个布尔处理机； 111条指令，其中49%指令为单字节指令，58%指令执行时间为一个 机器周期，有硬件乘除指令。 MCS-96系列单片机 可选项68脚48脚 数字I/O无ROM80968094 有ROM83968394 模拟和数字I/O无ROM80978095 有ROM83978395 主要特征 16位CPU 8KB ROM 232B RAM 硬件乘除指令 8个高速I/O单元 10位A/D 转换器 1个全双工串行I/O口 可编程8优先级中断系统 脉宽调制（PWM）输出 看门狗电路（Watchdog) ARM单片机简介&emsp;&emsp;ARM是Advanced RISC ( Reduced Instruction Set Computer) Machines 的缩写。 ARM公司不生产芯片，只从事处理器技术研发和技术授权转让，通过伙伴公司去生产基于ARM核的单片机芯片。 ARM系列单片机实际上是对基于ARM处理器核而设计的一类单片机的泛称，也常被称为ARM系列微控制器。 应用较多的主要有ARM7、ARM9等 6个系列。目前在32位单片机市场上，ARM实际上已扮演着类似于8位单片机市场上8051的角色。 ARM内核处理器的特点 体积小，功耗低，成本低、性能高 采用RISC指令集 支持ARM（32位）/Thumb（16位）双指令集，能很好地兼容8位/16位器件 大量使用寄存器，指令执行速度快 大多数数据操作都在寄存器中完成 寻址方式简单灵活，执行效率高 指令长度固定 MCS-51单片机的硬件结构MCS-51片内结构按功能可分成8个部件，通过片内单一总线连接起来控制方式：SFR对各功能部件集中控制 MCS-51片内资源MCS-51单片机分为 51、52 两个子系列，52子系列较51子系列资源略丰富 8位CPU 内部程序存储器 51子系列 4K 52子系列 8K 内部数据存储器 51子系列 128B 52子系列 256B 专用寄存器SFR 128B 外部程序存储器寻址空间 64K 外部数据存储器寻址空间 64K 输入/输出口I/O 4个 每个I/O口8根口线 定时器/计数器 51子系列 2个16位 52子系列 3个16位 串行口 4种工作方式，可通过编程选定 全双工串行口 中断 5个中断源、2个中断优先级 通用寄存器区 内部RAM中开辟了4个寄存器区 每个寄存器区有8个工作寄存器 堆栈 堆栈位置可编程设定 深度可达128字节 布尔处理机 内部RAM的20H~2FH SFR中12字节 指令系统 111条指令]]></content>
      <tags>
        <tag>单片机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rEFInd引导arch]]></title>
    <url>%2F2018%2F03%2F21%2FrEFInd%E5%BC%95%E5%AF%BCarch%2F</url>
    <content type="text"><![CDATA[使用rEFInd引导系统，配置文件简单，可以自动检测启动项。所以，果断淘汰掉grub2，改用rEFInd。 安装Arch中安装rEFInd安装很简单pacman -S refind-efi 配置手动配置Arch Linux菜单，添加菜单项如下123456789101112menuentry &quot;Arch Linux&quot; &#123; icon /EFI/refind/refind-theme-regular/icons/128-48/os_arch.png loader /vmlinuz-linux initrd /initramfs-linux.img options &quot;root=UUID=c42c79b5-559e-48b5-8738-dc0c8af43d63 rw quiet initrd=intel-ucode.img&quot; submenuentry &quot;Boot using fallback initramfs&quot; &#123; initrd initramfs-linux-fallback.img &#125; submenuentry &quot;Boot to terminal&quot; &#123; add_options &quot;systemd.unit=multi-user.target&quot; &#125;&#125; 这里options后为内核参数，UUID指的是根目录GUID，Intel CPU要加内核参数initrd=intel-ucode.img，这里的intel-ucode.img在ESP分区下]]></content>
      <tags>
        <tag>Arch</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wine依赖记录]]></title>
    <url>%2F2018%2F03%2F08%2Fwine%E4%BE%9D%E8%B5%96%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录下安装Crossover时指定安装的依赖，以便以后删除时一起卸载1lib32-freetype2 lib32-gcc-libs lib32-glibc lib32-libice lib32-libpng lib32-libsm lib32-libx11 lib32-libxext python2-dbus lib32-lcms2 安装deeping-qq需要wine_gecko lib32-mpg123]]></content>
      <tags>
        <tag>Arch</tag>
        <tag>Linux</tag>
        <tag>Crossover</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBox从U盘启动]]></title>
    <url>%2F2018%2F02%2F28%2FVBox%E4%BB%8EU%E7%9B%98%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[在U盘上装了个arch，想使用VBox从U盘启动，在网上找到了方法，其实不仅仅是U盘，可以是任何一块硬盘。方法记录在这里 使用VBox的用户需要加入vboxusers组更改权限用户需要对要使用的U盘设备文件有读写权限 sudo chmod o+rw /dev/sdx 创建VMDK文件在帮助VBox帮助文档上找到以下内容 To create an image that represents an entire physical hard disk (which will not contain any actual data, as this will all be stored on the physical disk), on a Linux host, use the commandVBoxManage internalcommands createrawvmdk -filename /path/to/file.vmdk -rawdisk /dev/sdx 执行上边这条命令后，使虚拟机从刚刚创建到vmdk文件启动即可 每次想从U盘启动时都要先执行一次第二步 从硬盘的指定分区启动帮助文档如下： To create a special image for raw partition support (which will contain a small amount of data, as already mentioned), on a Linux host, use the commandVBoxManage internalcommands createrawvmdk -filename /path/to/file.vmdk -rawdisk /dev/sda -partitions 1,5As you can see, the command is identical to the one for “full hard disk” access, except for the additional -partitions parameter. This example would create the image /path/to/file.vmdk (which, again, must be absolute), and partitions 1 and 5 of /dev/sda would be made accessible to the guest.]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保持ssh连接]]></title>
    <url>%2F2018%2F02%2F27%2F%E4%BF%9D%E6%8C%81ssh%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[使用ssh连接远程服务器经常被强行中断，使用mosh可以避免这一问题，但mosh无法向上翻页，还是想使用ssh，在网上找到了些解决办法。在此记录其中两种。 配置服务端在服务端配置文件 /etc/ssh/sshd_config 中添加以下内容 12ClientAliveInterval 30 ClientAliveCountMax 60 第二行配置表示如果发送 keep-alive 包数量达到 60 次，客户端依然没有反应，则服务端 sshd 断开连接。如果什么都不操作，该配置可以让连接保持 30s*60=30 min.配置完成后重启sshd 配置客户端还可以通过客户端配置实现，在客户端配置文件/etc/ssh/ssh_config中添加以下内容12ServerAliveInterval 30 ServerAliveCountMax 60 本地 ssh 每隔30s向 server 端 sshd 发送 keep-alive 包，如果发送 60 次，server 无回应断开连接。]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用VPS闲置资源挂机换美刀]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%88%A9%E7%94%A8VPS%E9%97%B2%E7%BD%AE%E8%B5%84%E6%BA%90%E6%8C%82%E6%9C%BA%E6%8D%A2%E7%BE%8E%E5%88%80%2F</url>
    <content type="text"><![CDATA[挂机需安装vncserver、一个轻量级桌面以及firefox，在debian9下我安装的是tightvncserver、openbox和firefox-esr。 挂ebesucher有两种方式 安装firefox&lt;54版本，安装ebesucher扩展进行挂机 打开挂机页面 https://www.ebesucher.com/surfbar/USERNAME 进行挂机,可设置该页面为主页 挂Vagex下载firefox Vagex扩展，设置扩展跟随浏览器启动进行挂机 更好的挂机设置定时任务由于VPS配置较低，浏览器可能崩溃，可设置定时任务定时重启vncserver，并设置firefox跟随openbox自启动 对firefox进行配置 设置浏览器不保存历史记录 设置浏览器不保存cookies 打开about:config 搜索 browser.privatebrowsing.autostart 設定為true]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh替代工具mosh]]></title>
    <url>%2F2018%2F01%2F24%2Fssh%E6%9B%BF%E4%BB%A3%E5%B7%A5%E5%85%B7mosh%2F</url>
    <content type="text"><![CDATA[放假回家，才发现广电宽带跟校园网简直没法比，这次真是见识到了GFW的威力，不到十天，给我封了三四个IP了。ssh连接VPS也老是掉线，甚至连不上去，终于在网上找到一个很棒的工具——mosh，跟ssh类似，同时需要服务端和客户端，使用方法也很像，使用命令mosh USERNAME@IP。若更改了ssh默认端口，比如改为9559，则命令为mosh --ssh=&quot;ssh -p 2022&quot; USERNAME@IP其他复杂配置没有仔细研究，这些对我来说就足够用了]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transmission错误记录]]></title>
    <url>%2F2018%2F01%2F24%2Ftransmission%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在VPS上使用transmission-daemon时出现以下错误12UDP Failed to set receive buffer: requested 4194304, got 425984 (tr-udp.c:84) UDP Failed to set send buffer: requested 1048576, got 425984 (tr-udp.c:95) 这是UDP缓存区不足引起的，可调大UDP缓冲区解决12sysctl -w net.core.rmem_max=4195328 sysctl -w net.core.wmem_max=4195328 执行以上命令，并写入/etc/sysctl.conf中]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
        <tag>transmission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh防暴力破解]]></title>
    <url>%2F2018%2F01%2F14%2Fssh%E9%98%B2%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[查看多次登录失败IPgrep &quot;Failed password for root&quot; /var/log/auth.log | awk &apos;{print $11}&apos; | sort | uniq -c | sort -nr | grep -v &quot;;&quot; 更改ssh端口设置强密码使用denyhosts]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动控制原理第四章]]></title>
    <url>%2F2018%2F01%2F06%2F%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%864%2F</url>
    <content type="text"><![CDATA[根轨迹分析法根轨迹的基本概念根轨迹图是闭环系统特征方程的根（即闭环极点）随开环系统某一参数由零变化到无穷大时在S平面上的变化轨迹。 绘制根轨迹的基本规则 根轨迹起始于开环极点，终止于开环零点。如果开环零点数目m小于开环极点数目n，则有n-m条根轨迹中止于无穷远处 根轨迹的分支数等于特征方程的阶次，也等于开环极点的个数 根轨迹是对称于实轴的连续曲线 若实轴上某点右边的开环零、极点个数和为奇数，则该点是根轨迹上的点。共轭复数开环零、极点对确定实轴上的根轨迹无影响 如果系统的开环零点数m少于其开环极点数n，则当根轨迹增益${K^* \to \infty}$时，趋向无穷远处根轨迹的渐近线共有n-m条。这些渐近线在实轴上共交于一点，其坐标是$(-\frac{\sum_{j=1}^n p_j-\sum_{i=1}^m z_i}{n-m},j0)$,而它们与实轴正方向的夹角为$\frac{\pm180(2k+1)}{n-m}$,其中$k$可取$0,1,2,…n-m-1$。 根轨迹分离点或会合点的坐标，可以通过求解方程$\frac{d[G(s)H(s)]}{ds}=0$或者$\sum_{j=1}^n\frac1{s+p_j}=\sum_{i=1}^m\frac1{s+z_i}$的根得到 根轨迹与虚轴的交点坐标及临界根轨迹增益，可以通过用$s=jω$代入系统闭环特征方程求取，也可以应用劳斯判据列表的方法确定 开环复数零、极点的出射角和入射角可根据下面的公式计算]]></content>
      <tags>
        <tag>自动控制原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动控制原理2、3章]]></title>
    <url>%2F2018%2F01%2F06%2F%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%862%E3%80%813%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[控制系统的数学描述 传递函数是线性定常系统的一种输入、输出关系描述，它取决于系统（或元件）的结构和参数，与输入函数无关（与外作用和初始条件无关）。 反馈控制的系统，适当地匹配结构参数，有可能获得较高的工作精度和很强的抑制干扰的能力，同时又具备理想的复现、跟随指令输入的性能，这是反馈控制优于开环控制之处。 控制系统的时域分析法经典控制理论方法包括时域分析法、根轨迹分析法和频域分析法 一阶系统时域分析对于$G(s)=\frac 1 {Ts+1}$的一阶系统 单位阶跃响应 ： 系统的稳态误差不可能为零 单位脉冲响应 ： 时间常数T越大，响应曲线下降得越慢，表明系统受脉冲输入信号作用后，恢复到初始状态的时间越长。反之，曲线下降得越快，恢复到初始状态的时间越短。不论T取何值，单位脉冲响应的终值均为零 单位斜坡响应 ： 一阶系统在跟踪单位斜坡信号时，存在位置误差，并且位置误差的大小随时间增大，最后趋于时间常数T。因此，减小时间常数T，不仅可以提高系统的响应速度，还可以减小系统对斜坡输入的稳态误差。 二阶系统时域分析典型二阶系统闭环传递函数$$G_B(s)=\frac {ω_n^2}{s^2+2ζω_ns+ω_n^2}$$$ωn$称为无阻尼自然振荡频率，ζ称为阻尼比系统的两个特征根 $$s{1,2}=-ζω_n\pmω_n\sqrt {ζ^2-1}$$ 过阻尼情况，$\zeta$&gt;1 临界阻尼情况，$\zeta$=1 欠阻尼情况，0&lt;$\zeta$&lt;1 无阻尼情况，$\zeta$=0 负阻尼情况，$\zeta$&lt;0 在一定ζ值下，欠阻尼系统比临界阻尼系统更快地达到稳态值，过阻尼系统反应迟钝，动作很缓慢，所以一般系统大多设计成欠阻尼系统 欠阻尼二阶系统在单位阶越输入作用下的瞬态响应指标 上升时间$t_r$ $$ t_r=\frac {π-φ}{ω_d} \text{ 式中,}φ=arctan\frac{\sqrt {1-ζ^2}}{ζ} $$ 峰值时间$t_p$ $$ t_p=\frac{π}{ω_d}=\frac {π}{ω_n\sqrt {1-ζ^2}}$$ 最大百分比超调量σ% $$ σ\%=e^{-ζπ/\sqrt {1-ζ^2}}*100\%$$ 调节时间$t_s$$$ t_s=\frac4{ζω_n}=4T,\Delta=2\%$$ $$ t_s=\frac3{ζω_n}=3T,\Delta=5\%$$ 提高增益可以使响应初始段加快，但振荡强烈，平稳性下降 改善二阶系统性能的措施误差的比例-微分控制 引入误差微分控制$1+T_ds$,$T_d$称为微分时间常数 等效阻尼比$$\zeta_d=\zeta+\frac{T_d\omega_n}2$$ 增大了系统的阻尼比（$\zeta_d&gt;\zeta$），使系统动态过程的超调量下降，平稳性提高，同时系统的无阻尼振荡频率$\omega_n$不发生改变，调节时间缩短，提高系统响应的快速性。 输出量的速度反馈控制 输出信号的导数可以用来改善系统的性能，为了获得输出位置信号的导数，需要采用测速发电机，以代替对输出信号的直接微分。 在系统中加入速度反馈，$K_t$称为速度反馈系数 等效阻尼比$$\zeta_t=\zeta+\frac{K_t\omega_n}2$$ 两种措施分析 在相同条件下，比例-微分控制的超调量要大一些 从现实的角度来看，比例-微分控制可以采用模拟电路来实现，因此，结构比较简单，易于实现，且成本低；而速度反馈控制所用的部件，例如测速发电机或其他速度传感器价格较高。 从抗干扰的能力来看，微分器对输入信号中的噪声，特别是高频噪声有放大的作用。而速度反馈信号是引自经过具有较大惯量的电机滤波之后的输出，噪声成分很弱，所以速度反馈抗干扰能力强。 线性定常系统的重要特性 初始条件为零的线性定常系统 当系统输入信号为原来输入信号的导数时，系统的输出为原来输出的导数 当系统输入信号为原来输入信号对时间的积分时，系统的输出则为原来输出对时间的积分 单位脉冲响应是单位阶跃响应对时间的一阶导数。单位阶跃响应可以由单位斜坡响应t和单位抛物线响应对时间的一阶导数和二阶导数求得 单位斜坡响应和单位抛物线响应是单位阶跃响应对时间的一重和二重积分 高阶系统的时域分析主导极点假如高阶系统中距离虚轴最近的极点，其实数部分为其它极点的1／5或更小，并且附近又没有零点，则可认为系统的响应主要由该极点(或共轭复数极点)决定，这一分量衰减最慢。这种对系统瞬态响应起主要作用的极点，称为系统的主导极点 如果二阶系统包含有零点，且该零点位于主导极点附近，则会对系统的瞬态响应产生影响 不能忽略零极点的影响 一个不能忽略的零点对系统的影响是使超调量加大，响应速度加快 一个不能忽略的极点对系统的影响是使超调量减小，调节时间增加 线性系统的稳定性分析 劳斯－赫尔维茨(Routh－Hurwitz)判据，代数判据方法 （第三章） 根轨迹法，图解求特征根的方法（第四章） 奈魁斯特(Nyquist)判据，基于复变函数理论的方法（第五章） 李雅普诺夫方法，适用于线性系统和非线性系统 稳定性概念系统在受到外作用力后，偏离了正常工作点，而当外作用力消失后，系统能够返回到原来的工作点，则称系统是稳定的 在有界输入的作用下，其输出响应也是有界的。这叫做有界输入有界输出稳定，又简称为BIBO (Bounded-Input Bounded-Output)稳定 线性系统稳定的充分必要条件所有特征根均为负实数，或具有负的实数部分 劳斯判据(Routh Criterion)应用劳斯判据的优点应用劳斯判据不仅可以判别系统稳定不稳定，即系统的绝对稳定性，还可以检验系统是否具有一定的稳定裕量，即相对稳定性。同时可以用来求解系统稳定的临界参数，分析系统参数对稳定性的影响 根据特征方程式构造劳斯阵列表 第一列系数均为正数，系统稳定 第一列系数有负数，则第一列系数符号的改变次数等于在右半平面上根的个数 特殊情况1劳斯阵列表中某一行的第一个系数为零，其余各系数不全为零(或没有其余项) 特殊情况2劳斯阵列表中某一行(设为第k行)的所有系数均为零，则说明在根平面内存在一些大小相等、关于原点对称的根 劳斯判据应用 稳定裕量(Stability margin)的检验 分析系统参数对稳定性的影响 线性系统的稳态误差稳态误差与输入信号和系统的结构、参数有关增加型号数，可使系统精度提高，但对稳定性不利 扰动输入引起的稳态误差为了降低或消除扰动引起的稳态误差，可以增大扰动作用点之前的前向通道的放大系数或通过在扰动作用点之前引入积分环节的办法来实现。但往往会给系统带来结构不稳定现象 关于降低稳态误差问题增大系统开环放大系数可以增强系统对参考输入的跟随能力；增大扰动作用点以前的前向通道放大系数可以降低扰动引起的稳态误差。 增加前向通道中积分环节数，使系统型号提高，可以消除不同输入信号时的稳态误差。 保证元件有一定的精度和稳定的性能，尤其是反馈通道元件如果作用于系统的主要干扰可以测量时，采用复合控制来降低系统误差，消除扰动影响。]]></content>
      <tags>
        <tag>自动控制原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[串行通信]]></title>
    <url>%2F2018%2F01%2F05%2F%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[计算机与外部交换信息称为通信，包括 并行通信 — 计算机数据各位同时传送 串行通信 — 数据逐位传送 串行通信的特点 串行通信只要一根数据线 传输速度较慢 接口电路复杂 串行通信的应用 只能接收串行信号的设备或只能串行输出设备 长距离传送 串行通信类型串行通信有同步和异步两种通信类型 异步串行通信在异步通信中，信息“1”称为传号（MARK），信息“0”称为空号（SPACE）。 异步通信格式说明 无传输：发送方连续发送传号 起始传输：发送方第一次将传号变成空号并持续一位（起始位），接收方以此下降沿与发送方同步 数据传输：起始位之后的5~8位为数据位，低位在前。传输位数由双方约定 奇偶传输：有的系统将最后一位数据位作为奇偶校验以增加系统的可靠性 停止传输：最后发送停止位，停止位状态恒为“1”，长度1，1.5，2位，可以选择。 异步串行通信的数据校验错 奇偶错：由奇偶校验查出的错误 超越错：接收端收到一个字符未处理，又收到第二个字符 帧格式错：未收到有效停止位。 异步串行通信的特点 以字符为单位发送，字符之间的间隔不受限制 由起始位和停止位使收发双方同步 通信的精确格式可以由收发双方选择。 同步通信同步通信是由一个起始同步符和若干个数据位以及一个检验字段组成，传输的数据可以以字符为单位，也可以以二进制位为单位，因此同步传输也称为数据流传输 同步通信的特点同步通信以同步符作为一帧数据的起始标志，因此在传输的数据中不能包含有同步符。在实际应用中采用自动加“0”技术避免数据中出现同步符。同步通信中一般数据位可达上千位，因此传输效率较高，传输速度较快。同步通信中传输位数较多，因此要求收发时钟严格同步。传输中采用“曼彻斯特”编码，数据中隐含时钟信息 串行通信的传输方式信号传输速率—波特率（Baud Rate）波特率是每秒传输的二进制位数常用的波特率有：110,300，600，900，1200，2400，4800，9600，19200，2400，4800，9600，19200，38400，57600，115200 线路传输方式 单工方式：数据只能按一个固定方向传输。如：寻呼系统 半双工方式：可以2个方向传送，但不能同时传送。如：电话 全双工方式：双方可以同时传送 信号传输方式 基波传输方式基波传输又称基带传输，按信号原样进行直流传输。这种方式适合于近距离慢速传输。 模拟载波传输方式使用调制解调器将数字信号转换成模拟信号进行传输。调制方式： 移幅键控（ASK）由两种幅度正弦波表示“0”和“1” 移频键控（FSK）由两种频率正弦波表示“0”和“1” 移相键控（PSK）由正弦波两种相位表示“0”和“1” 串行通信的校验方法奇偶校验（Parity Check）发送时每个字符的最高位之后附加一个奇偶校验位，以保证整个字符（包括奇偶校验位）为“1”的位数为奇数（奇校验）或为偶数（偶校验）接收时按照发送方所确定的同样的奇偶性对收到的字符进行校验 循环冗余校验CRC（Cyclic Redundancy Check）CRC校验是用一个固定数去除信息码得出余数，将此余数附加在原信息之后，成为CRC字符接收方用同样的数去除含有CRC字符的信息，若接收无错误，则结果为0。 串行接口RS-232C标准EIA RS-232C是美国电子工业协会（Electronic Industry Association）推荐标准（Recommanded Standard）RS-232C是目前最常用的一种异步串行通信接口]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模数/数模 转换]]></title>
    <url>%2F2018%2F01%2F05%2F%E6%A8%A1%E6%95%B0-%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[D/A转换器——DAC0832 控制信号 $ILE \cdot \overline{CS}\cdot\overline{WR1}$有效使数据进入输入寄存器 $\overline{WR2}\cdot\overline{XFER}$有效，数据到DAC。 输出信号 IOUT1：DAC电流输出1 IOUT1 = （VREF/15k）* N/256 IOUT2：DAC电流输出2 IOUT2 = （VREF/15k）*（256-N）/256 Rfb：反馈电阻，其值为15k，温度特性与电阻网络相同，为DAC提供输出电压，用作运放反馈电阻 VREF：参考电压输入，外部精密电压源接到内部R－2R梯形电阻网络，范围：-10~+10V A/D转换器 V-F变换器： 准ADC、串行输出（单积分式） 积分式ADC: 精度高、抗干扰能力强、速度慢 逐次逼近式ADC(ADC0809/ADC0804): 精度高、速度较快、电路复杂 并行ADC：速度最快、电路复杂、位数难做多比较器数量M与位数N之间关系为M = 2^N-1 典型ADC及其应用 — ADC0804 DB7~DB0：数据线，三态，输出，可直接接总线 启动： $\overline{WR}\cdot\overline{CS}$ 启动ADC，同时清状态INTR 状态：$\overline{INTR}$转换结束输出低电平 读数据：$\overline{RD}\cdot\overline{CS}$ 打开三态门读取数据，同时清状态。]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可编程接口芯片8255]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%8F%AF%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E8%8A%AF%E7%89%878255%2F</url>
    <content type="text"><![CDATA[8086系统常用可编程接口芯片并行接口芯片 INTEL8255，有三个8位端口A、B、C INTEL8155，有三个端口，内带256字节RAM，两个定时器 串行接口芯片 INTEL8251，同步异步串行接口 INTEL8250，异步串行接口芯片 计数定时器 INTEL8253/8254，三个通道16位定时计数器 直接内存访问控制器（DMA） INTEL8237 8255A结构RESET 复位信号，输入，高电平有效。复位后清所有内部寄存器 8255A控制字方式控制字 8255A有三种工作方式 方式0：无条件输入输出A、B、C口均可工作于此方式，用作输入或输出口在此方式下，CPU可直接用IN、OUT指令读取端口状态或输出数据到端口 方式1：选通输入输出 方式2：双向方式 A口可工作在三种工作方式，B口仅可工作在方式0和方式1 在方式1和方式2中C口作为联络信号 端口C按位控制字 按位控制字写入8255的控制口 该控制字仅对8255端口C的输出锁存器操作 该控制字主要用于方式1和方式2，方式0下可直接对C口操作]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可编程计数器8253]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%8F%AF%E7%BC%96%E7%A8%8B%E8%AE%A1%E6%95%B0%E5%99%A88253%2F</url>
    <content type="text"><![CDATA[控制口 SC1 SC0 计数器选择 RW1 RW0 计数器读/写选择 0 0 计数器0 0 0 锁存计数器当前计数值 0 1 计数器1 0 1 读/写计数值低8位 1 0 计数器2 1 0 读/写计数值高8位 1 1 非法 1 1 先低8位，再高8位 M2 M1 M0 计数器工作方式选择 BCD 计数器进制选择 0 0 0 方式0 0 16位二进制计数 0 0 1 方式1 1 BCD码计数 x 1 0 方式2 x 1 1 方式3 1 0 0 方式4 1 0 1 方式5 方式0 — 计数结束产生中断方式 写入控制字后OUT即变为低电平，计数到0时，OUT变为高电平，并停止计数 计数初值N写入后在下一个CLK下降沿才送入计数装置开始计数，因此实际计数为N+1个脉冲 GATE为高电平时允许计数，为低电平时停止计数 若计数过程中写入新的计数初值，则在下一个CLK按新值重新计数 方式1 — 可重新触发单稳态触发器方式 写入控制字后OUT即变为高电平，等待GATE上升沿后，下一个CLK的下降沿才开始计数，并置OUT为低电平，计数到0时OUT又变为高电平 计数结束后，若GATE端再来上升沿，则会再次触发一轮计数周期 若计数过程中写入新的计数初值，需等待GATE端再次触发后才按新的初值计数 方式2 — 分频器方式 写入控制字后OUT即变为高电平，写入计数初值后，下一个CLK的下降沿开始计数，减到1时OUT变为低电平，持续一个CLK后OUT又变为高电平，并自动开始下一次计数过程。 Fout = Fclk/N GATE为高电平时允许计数，为低电平时停止计数 计数期间送入新值，不影响当前计数周期，下一周期才按新值计数 方式3 — 方波发生器方式 写入控制字后OUT即变为高电平，写入计数初值后，下一个CLK的下降沿开始计数，计数到一半时OUT变为低电平，计到终值时OUT又变为高电平，并自动开始下一次计数过程。 Fout = Fclk / N 若N为偶数，则高、低电平持续时间相等，均为N/2个CLK，即OUT输出为方波；若N为奇数，则高电平持续时间为(N+1)/2个CLK，低电平持续时间为(N–1)/2个CLK GATE为高电平允许计数，为低电平则停止计数 计数期间送入新值，不影响当前计数周期，下一周期才按新值计数 方式4 — 软件触发选通方式 写入控制字后OUT即变为高电平，写入计数初值后，下一个CLK的下降沿开始计数，计数到0时，OUT输出一个CLK的负脉冲，并停止计数 GATE为高电平允许计数，为低电平则停止计数 若计数过程中写入新的计数初值，则在下一个CLK按新值重新计数 方式5 — 硬件触发选通方式 写入控制字后OUT即变为高电平，写入计数初值，等待GATE上升沿后。下一个CLK的下降沿才开始计数，计数到0时OUT输出一个CLK的负脉冲，并停止计数 计数结束后，若GATE端再来上升沿，则会再次触发一轮计数周期 若计数过程中写入新的计数初值，需等待GATE端再次触发后才按新的初值计数]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可编程中断控制器8259]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%8F%AF%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A88259%2F</url>
    <content type="text"><![CDATA[内部结构 IRR — 中断请求寄存器，保存 8个输入端IR0~IR7的中断申请状态，输入可高电平有效，也可上升沿有效 ISR — 中断服务寄存器，保存CPU正在处理的中断请求 IMR — 中断屏蔽寄存器，对中断申请进行屏蔽控制 中断优先级分析器决定中断申请的优先级把初始化命令字和操作命令字结合进行设置，可以有四种优先级管理方式 全嵌套方式(中断请求按优先级0-7进行处理，0级中断的优先级最高) 自动循环方式（优先级相等。这种方式下，优先级队列是在变化的，一个设备受到中断服务后，它的优先级自动降为最低） 特殊循环方式（设置最低优先级） 特殊的全嵌套方式（可在级联时使用,与全嵌套方式基本相同，不过允许同级中断） 控制逻辑 初始化命令寄存器组：ICW1~ICW4 操作命令寄存器组： OCW1~OCW3 INT 中断申请输出，高电平有效，可连接8086 INTR引脚 $\overline{INTA}$ 中断响应输入，接收8086发出的中断响应信号，有效时8259应输出中断类型码 D7~D0 双向三态数据线，传送数据 $\overline{RD}$ 读信号，低电平有效 $\overline{WR}$ 写信号，低电平有效 $\overline{CS}$ 片选信号，低有效，给8259分配地址 A0 用于选择8259内部不同的寄存器。 CAS2~CAS0 级联信号线，当8259为主片时为输出，从片时为输入 $\overline{SP}/\overline{EN}$ 在非缓冲工作方式时，用作输入，决定8259A为主片还是从片,主片接+5V，从片接地；在缓冲工作方式时，用作输出，由它打开总线缓冲器 初始化命令字初始化命令字一般在初始化8259时才写入，而且写入有严格的顺序，先写ICW1，最后写ICW4 ICW1(芯片控制) A0 D7 D6 D5 D4 D3 D2 D1 D0 0 0 0 0 1 LTIM 0 SNGL IC4 A0=0，D4=1 表示对ICW1编程 D0（IC4） D0=1 需要ICW4 D0=0 不需要ICW4 D1（SNGL） D1=1 为单片8259工作方式 D1=0 为级联工作方式，此时要用ICW3指明级联端 D2（ADI） 指明8080/8085系统中地址间距, 8086系统不用 D3（LTIM） D3=1 中断请求是电平触发方式 D3=0 上升沿触发方式 D5~D7（A5~A7） 8080/8085系统中断服务程序页面地址， 8086系统不用 ICW2(类型) A0 D7 D6 D5 D4 D3 D2 D1 D0 1 T7 T6 T5 T4 T3 T2 T1 T0 A0=1，跟在ICW1后表示对ICW2编程 A15~A8 为8080/8085系统中页面地址高8位 T7~T3 为8086系统中的中断类型码的高5位，低3位根据申请端自动填充 ICW3(主/从) A0 D7 D6 D5 D4 D3 D2 D1 D0 1 主片 S7 S6 S5 S4 S3 S2 S1 S0 1 从片 0 0 0 0 0 ID2 ID1 ID0 A0=1，且ICW1的D1(SNGL)=0，跟在ICW2后表示对ICW3编程 主片 Si=1 表示第IRi引脚上连接有从片 从片 ID2~ID0对应从片的识别码，即表明从片连接到主片的第几个输入引脚上。CPU发出第一个中断响应负脉冲$\overline{INTA}$时，主片通过CAS2 ~CAS0送出识别码通知有中断请求的从片，每个从片将CAS2~CAS0上信号与自己内部的识别码(ID2~ID0)相比较，若相同，则在第二个$\overline{INTA}$信号到来时送出自己的中断类型码。 ICW4(方式控制) A0 D7 D6 D5 D4 D3 D2 D1 D0 1 0 0 0 SFNM BUF $M/\overline{S}$ AEOI 1 A0=1，且ICW1的D0=1，跟在其他初始化字后表示对ICW4编程 D0（μpm） D0=1 为非8位处理器体系 D0=0 为8位处理器体系 D1（AEOI） D1=1 自动结束中断方式，在第二个$\overline{INTA}$清ISR(中断服务寄存器)中的对应位 D1=0 非自动结束中断方式，中断结束时发EOI命令清ISR中的对应位 D2（$M/\overline{S}$） 在缓冲方式下（BUF=1)，选择主片和从片，$M/\overline{S}$=1为主片，$M/\overline{S}$=0为从片。 在非缓冲方式下，则$M/\overline{S}$不起作用，可为1，也可为0. 由$\overline{SP}/\overline{EN}$引脚设定主片和从片(接高电平为主片，接低电平为从片)。 D3（BUF） D3=1 为缓冲工作方式，$\overline{SP}/\overline{EN}$为缓冲选通信号。 D3=0 为非缓冲工作方式。 D4（SFNM） D4=1 为特殊全嵌套方式，此时允许同级中断再次进入，一般用于多片级联方式 D4=0 为普通全嵌套方式，禁止同级中断再次进入。 操作命令字 OCW1(IMR)A0=1 表示设置OCW1 Mi=1 表示屏蔽IRi输入中断请求 OCW2A0=0，且D4D3 = 00，表示对OCW2编程 R 优先权循环状态 R=1 优先权自动循环 R=0 优先权不循环 SL 设定标志 SL=1 L2、L1、L0有效 SL=0 L2、L1、L0无效 EOI 中断结束命令标志 EOI=1,非自动结束方式时清ISR中对应位 一般EOI指令(普通结束指令)为 MOV AL, 20H OUT 20H, AL L2 L1 L0 指明中断号或最低优先权 OCW3A0=0，且D4D3 = 01，表示对OCW3编程 ESMM SMM 1 1 设置特殊屏蔽，无优先级，未屏蔽中断申请均可进入 1 0 取消特殊屏蔽 0 × 无操作 P=1 ，设置8259A为查询工作方式，此时8259A不发INT信号，CPU通过查询指令决定服务程序查询得到格式如下表所示I=1 表示有中断请求W2 W1 W0为当前最高优先级的中断请求中断号 P=0，由RR和RIS设置下一个读取的寄存器 RR RIS 1 0 在下一个A0=0端口读IRR(中断请求寄存器) 1 1 在下一个A0=0端口读ISR(中断服务寄存器)]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[存储/输入输出接口/中断]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%AD%98%E5%82%A8-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3-%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[存储系统 中断系统硬件中断 可屏蔽中断 — 输入为INTR引脚，高电平有效，受IF标志控制 非屏蔽中断— 输入为NMI引脚，上升沿有效，不受IF控制 软件中断 除法溢出中断（DIV和IDIV）（INT 0） 若除数为0或商超过寄存器所能表达的范围，则产生类型为0的软件中断 单步中断 （INT 1） 若TF=1，则CPU每执行完一条指令后便产生类型码为1的软件中断 执行INT指令引起的中断（INT n） 执行INT n指令则会引起中断类型码为n的软件中断 执行 INTO 指令引起的中断（INT 4） 若OF=1，则指令INTO引起中断类型码为4的软件中断 中断优先级 软件中断（单步中断除外） 优先级最高 NMI中断 INTR中断 单步中断 优先级最低]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch安装配置sublime text 3]]></title>
    <url>%2F2018%2F01%2F04%2FArch%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEsublime-text-3%2F</url>
    <content type="text"><![CDATA[安装 Install the GPG key curl -O https://download.sublimetext.com/sublimehq-pub.gpg &amp;&amp; sudo pacman-key --add sublimehq-pub.gpg &amp;&amp; sudo pacman-key --lsign-key 8A8F901A &amp;&amp; rm sublimehq-pub.gpg Select the channel to use Stableecho -e &quot;\n[sublime-text]\nServer = https://download.sublimetext.com/arch/stable/x86_64&quot; | sudo tee -a /etc/pacman.conf Devecho -e &quot;\n[sublime-text]\nServer = https://download.sublimetext.com/arch/dev/x86_64&quot; | sudo tee -a /etc/pacman.conf Update pacman and install Sublime Text sudo pacman -Syu sublime-text 中文输入法 git clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix./sublime-imfix 插件 chineselocalizationsCodecs33converttoutf8package controlsublimereplALL AutocompleteCoolFormatHexViewerMasmAssemblySublimeAStyleFormatterSublimeBashTidySublimeGitTerminal]]></content>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch系统备份与还原]]></title>
    <url>%2F2018%2F01%2F04%2FArch%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[arch系统备份与还原备份 安装pigzsudo pacman -S pigz 执行以下命令sudo tar --use-compress-program=pigz -cvpf /home/beta/Documents/arch-backup.tgz --exclude=/boot --exclude=/home --exclude=/proc --exclude=/dev --exclude=/sys --exclude=/tmp --exclude=/run --exclude=/lost+found --exclude=/mnt --exclude=/media --exclude=/var/lock --exclude=/var/run --exclude=/var/cache/pacman/pkg / 还原 从安装光盘/U盘启动 sudo nano /etc/pacman.d/mirrorlist配置源 安装pigz 挂载根分区到/mnt rm -rf /mnt/* （慎重） 解压tar --use-compress-program=pigz -xvpf /f/sysbackup/arch-backup.tgz -C /mnt 挂载home boot等分区 生成fstabgenfstab -U /mnt &gt; /mnt/etc/fstab arch-chroot到/mnt 重建grub grub-install –target=x86_64-efi –efi-directory=/boot –bootloader-id=archgrub-mkconfig -o /boot/grub/grub.cfg]]></content>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch常用软件]]></title>
    <url>%2F2018%2F01%2F03%2FArch%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[必要软件archlinuxcn-keyring bash-completion cronie yaourt neofetch tree pkgfile git make lsb-release ntfs-3g exfat-utils screen systemd-rc-local shellzsh oh-my-zsh-git zsh-syntax-highlightingzsh-autosuggestions(AUR) 字体及配置noto-fonts noto-fonts-cjk noto-fonts-emoji adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts ttf-roboto ttf-dejavu ttf-monaco ttf-ubuntu-font-family powerline-fonts 桌面gnome gdm mutter gnome-shell gnome-font-viewer gnome-terminal gnome-disk-utility gnome-calculator gnome-screenshot gnome-control-center gnome-system-monitor eog nautilus networkmanager xdg-user-dirs-gtk evince gvfs-nfs gvfs-afc gvfs-mtp gnome配置工具gnome-tweaks nautilus插件nautilus-admin nautilus-folder-icons nautilus-nutstore(AUR) 主题faba-icon-theme-git flatplat-blue-theme(AUR) 输入法fcitx输入法fcitx-im fcitx-configtool fcitx-rimeibus输入法ibus ibus-qt ibus-rime 下载axel wget aria2-fast uget transmission-gtk transmission-remote-gtk 浏览器firefox firefox-i18n-zh-cn google-chrome flashflashplugin pepper-flash 字典goldendict youdao-dict ydcv sdcv 影音netease-cloud-music spotify rhythmbox mpv baka-mplayer vlc youtube-dl you-get 网盘nutstore 代理proxychains-ng shadowsocks-qt5 lantern shadowsocksr-libev(AUR) VNC客户端vinagre 编辑器leafpad sublime-text atom visual-studio-code-bin 编程codeblocks clion pycharm-community ipython zeal-git officewps-office ttf-wps-fonts 虚拟机virtualbox virtualbox-guest-iso virtualbox-host-dkms 阅读器calibre fbreader foxitreader 防火墙gufw 系统监视htop gtop nethogs iftop vnstat 邮件geary Nylas mailspring evolution 图像处理gimp winewine wine-mono wine_geckowinetricks-zh-git(AUR) crossover(AUR) 通讯软件telegram-desktop franz-bin 压缩unzip-iconv p7zip-natspec pigz file-roller 磁盘管理gnome-disk-utility 热点create_ap haveged 负载均衡haproxy DOS模拟器dosemu 包管理器pamac-aur Teredo隧道miredo(AUR) 电路图eagle(AUR) 软件降级downgrade 文件搜索albert(AUR) 笔记本及硬盘工具hdparm laptop-mode-tools-git(AUR) 其他wmctrl xdotool xorg-xmodmap xorg-xinput gnome-shell-extensions applications menuclipboard indicatorcoverflow alt-tabdash to dockdrop down terminalinput method panellaunch new instancenative window placementremovable drive menushow desktop buttonsimple net speedtopicons plususer themesworkspace scroll gnome-shell-extensions目录 ~/.local/share/gnome-shell/extensions /usr/share/gnome-shell/extensions 鼠标/图标主题 /usr/share/icons/ ~/.icons gtk/gnome-shell主题 ~/.themes]]></content>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arch安装步骤]]></title>
    <url>%2F2018%2F01%2F01%2FArch-installation-guide%2F</url>
    <content type="text"><![CDATA[有线网络执行systemctl start dhcpcd,无线执行wifi-menu链接wifi更新系统时间 timedatectl set-ntp true分区格式化根分区 mkfs.ext4 /dev/sda挂载分区 mount /dev/sda7 /mntmkdir /mnt/bootmount /dev/sda2 /mnt/bootmkdir /mnt/homemount /dev/sda6 /mnt/home 编辑 /etc/pacman.d/mirrorlist安装基本系统pacstrap /mnt base base-devel 生成fstabgenfstab -U /mnt &gt; /mnt/etc/fstab change root到新系统arch-chroot /mnt 设置时区 ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock –systohc –utc 设置语言编辑/etc/locale.gen执行locale-gen 执行echo LANG=en_US.UTF-8 &gt; /etc/locale.conf设置主机名 echo Archpc &gt;&gt; /etc/hostnameecho “127.0.1.1 Archpc.localdomain Archpc” &gt;&gt; /etc/hosts 安装必要软件pacman -S gvim net-tools wireless_tools wpa_supplicant dialog intel-ucode os-prober grub efibootmgr openssh linux-headers 编辑 /etc/lvm/lvm.conf设置set use_lvmetad = 1 为 use_lvmetad = 0 安装grub grub-install –target=x86_64-efi –efi-directory=/boot –bootloader-id=grubgrub-mkconfig -o /boot/grub/grub.cfg 设置root密码 &amp; 添加普通用户 useradd -m -G wheel betaset beta passwordvisudo 其他配置安装桌面环境 安装必要软件包pacman -S xorg-xinit xf86-video-intel 安装gnome桌面pacman -S gnome执行echo &quot;exec gnome-session&quot; &gt;&gt; ~/.xinitrc后可通过startx命令进入桌面 设置中文startx进入中文桌面echo &quot;export LANG=zh_CN.UTF-8&quot; &gt;&gt; ~/.xinitrc桌面管理器进入中文桌面(最新gnome例外)echo &quot;export LANG=zh_CN.UTF-8&quot; &gt;&gt; ~/.xprofile 安装nvidia驱动 pacman -S nvidia bumblebee bbswitchecho “blacklist nouveau” &gt;&gt; /etc/modprobe.d/blacklist.conf 重启 设置fcitx输入法,将以下三行内容分别写入~/.xinitrc和~/.xprofile(gnome需写入/etc/environment)中 export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx 启用multilib仓库编辑 /etc/pacman.conf，取消下面内容的注释： [multilib]Include = /etc/pacman.d/mirrorlist 启用archlinuxcn源在/etc/pacman.conf中添加： [archlinuxcn]Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$archServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch]]></content>
      <tags>
        <tag>Arch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8086指令系统]]></title>
    <url>%2F2017%2F11%2F26%2F8086%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[指令是使计算机执行某种特定操作的二进制编码。8086 CPU指令系统有133条指令，通常分为数据寻址方式和程序寻址方式8086指令不定长，一般为1～6个字节。 数据寻址方式隐含寻址指令已经默认对CPU中的某个寄存器进行操作，不用在指令中指明所使用的寄存器，即隐含了规定的操作数，这样的寻址方式称为隐含寻址。 立即数寻址寄存器寻址存储器操作数寻址 执行单元EU根据指令中给出的寻址方式计算出16位的偏移量，称为有效地址(EA)送到总线接口单元BIU，经过加法器生成20位实际物理地址，在存储器读写总线周期对存储器进行操作，一般在表示EA时，用 [操作数] 表示。 由于计算EA需要时间，进行总线操作比较慢，因此存储器操作寻址比前三种要慢。 直接寻址例：MOV SI, [2000H]默认使用DS段，若需使用其他段可使用段超越：MOV SI, ES:[2000H] 寄存器间接寻址可间接寻址的寄存器有：BX、BP、SI、DI例：MOV AL, [BX] BX用于间接寻址时，默认段寄存器为DS，允许段超越 BP用于间接寻址时，默认段寄存器为SS，允许段超越 SI用于间接寻址时，默认段寄存器为DS，允许段超越 DI用于间接寻址时，只有在串操作指令中，默认段寄存器为ES,其余情况默认段寄存器均为DS，不允许段超越注：IP只能在代码段中(CS)寻址，SP只能在堆栈段(SS)中寻址 寄存器相对寻址 基址寻址操作数的有效地址是一个基址寄存器的内容加上一个8位或者16位的偏移量，基址寄存器是BX或者BP。例：MOV AX,[BX+1000H]有时也写成 MOV AX,1000H[BX]或MOV AX,[BX]1000H 变址寻址操作数的有效地址是一个变址寄存器的内容加上一个8位或者16位的偏移量，变址寄存器是SI和DI例：MOV AX, ARRAY[SI] 基址加变址寻址操作数的有效地址是由基址寄存器和变址寄存器的内容相加产生例：MOV AX, [BP+SI] 相对的基址加变址寻址操作数的有效地址是由基址寄存器、变址寄存器和偏移量三者相加产生例：MOV AX, [BX+SI+3H]也可写成MOV AX,3H[BX][SI]或MOV AX,3H[BX+SI] 数据串寻址DS:SI指示源串，ES:DI指示目的串，串长度计数用CX，并自动修改指针和计数器值，只用于串操作命令例：MOVSB ;((ES:DI))&lt;-((DS:SI))，CX=CX-1，SI=SI+1,DI=DI+1 I/O端口寻址操作数存放在I/O端口中，指令执行时必须通过累加器（AX或AL）实现对端口的访问 直接端口寻址指令直接提供8位端口的地址。例：IN AL, 63H当端口地址用一个字节来表示时,可使用直接端口寻址 间接端口寻址由DX寄存器给出16位端口地址。例：MOV DX, 162HIN AX, DX 程序寻址方式段内直接寻址 短跳转：把IP的内容加上一个字节的补码数作为新的IP，往前最多跳-128个字节，往后最多跳127个字节。 近跳转：把IP的内容加上两个字节的补码数作为新的IP，往前最多跳-32768个字节，往后最多跳32767个字节。 段内间接寻址将寄存器或存储器操作数的内容赋给IP 段间直接寻址直接在指令中给出新的CS和IP内容 段间间接寻址用存储器操作数的内容赋给CS和IP 8086指令格式指令一般由1～6个字节组成，具体格式如下图： 字节1 OPCODE：指令操作码 D：操作数传输方向(立即数指令和串操作指令除外) D=0，Reg为源操作数 D=1，Reg为目的操作数 W：操作数字节长度 W=0，字节操作 W=1，字操作 字节2，寻址方式 MOD：寻址方式字段 00＝存储器方式，指令中无偏移量 01＝存储器方式，指令中有8位偏移量 10＝存储器方式，指令中有16位偏移量 11＝寄存器方式，指令中无偏移量 Reg：寄存器编码字段 000=AL/AX 100=AH/SP 001=CL/CX 101=CH/BP 010=DL/DX 110=DH/SI 011=BL/BX 111=BH/DI R/M：寄存器/存储器字段 在MOD=11,寄存器模式下，R/M给出第二个操作数的寄存器编码 在MOD≠11,存储器模式下，R/M给出计算有效地址的方法。 字节3～字节6DISP：存储器操作数地址偏移量，长度由MOD字段定义 DATA：指令中的立即数 8086指令系统操作数符号表示 符号 含义 DST 目的操作数 SRC 源操作数 TARGET 循环、转移和调用指令操作数 IMM 立即操作数，字节或字 ACC 累加器AL或AX reg 寄存器操作数 seg_reg 段寄存器 MEM 存储器操作数 short_label 短标号（8位偏移量） near_label 近标号（16位地址或偏移） far_label 远标号（32位地址） 数据传送指令通用数据传送指令MOV DST,SRC 堆栈及堆栈操作堆栈是一种按先进后出（FILO）原则存取的存储器，它由堆栈指针寄存器SS:SP和RAM中的一部分组成，主要用于子程序调用或中断子程序的现场保护和恢复，以及参数传递等。SP的内容总是指向栈顶，即最后推入信息所在单元。 进栈指令 PUSH SRC 出栈指令 POP DST 交换指令 XCHG DST,SRC 累加器专用传送指令 输入指令 IN AL/AX,PORT/DX 输出指令 OUT PORT/DX,AL/AXPORT为8位直接地址 换码指令 XLAT ： (AL)←((BX)+(AL)) 地址传送指令 有效地址传送指令 LEA reg16,SRC:(reg16) ←SRC 指针送寄存器和DS LDS reg16,mem32 ：(reg16) ←(mem32)； (DS) ←(mem32+2) 指针送寄存器和ES LES reg16,mem32 ：(reg16) ←(mem32); (ES) ←(mem32+2) 标志寄存器传送 LAHF : (AH) ←(flag低字节) SAHF : (flag低字节) ←(AH) PUSHF : (SP) ←(SP)-2, ((SP)+1),(SP)) ←flag POPF : flag ←((SP)+1),(SP)), (SP) ←(SP)+2 算术指令加法指令 ADD DST,SRC ： (DST) ← (SRC) + (DST) ADC DST,SRC ： (DST) ← (SRC) + (DST)+CF INC DST ： (DST) ←(DST)+1 //不影响进位标志CF 减法指令 SUB DST,SRC ： (DST) ←(DST)-(SRC) SBB DST,SRC ： (DST) ←(DST)-(SRC)-CF DEC DST ： (DST) ←(DST)-1 //不影响进位标志CF NEG DST ： (DST)=0-(DST) //求补指令 CMP DST,SRC ： (DST)-(SRC),仅影响标志 //比较指令 乘法指令 无符号数乘法MUL SRC ： (AX) ←(AL)*(SRC)或(DX,AX) ←(AX)*(SRC) 有符号数乘法IMUL SRC ： (AX) ←(AL)*(SRC)或(DX,AX) ←(AX)*(SRC) 除法指令除数必须为被除数一半字长 无符号数除法指令 DIV SRC(AL) ←(AX)/(SRC)；(AH) ←(AX)%(SRC)或(AX)←(DX,AX)/(SRC)；(DX) ←(DX,AX)%(SRC) 有符号数除法指令 IDIV SRC ： 操作与DIV相同 类型转换指令 字节转换成字指令（有符号数）CBW若(AL) &lt;80H则(AH)←0，否则(AH) ←FFH即将AL符号位扩展到AH 有符号字转换成双字指令CWD若(AX)&lt;8000H,则(DX) ←0,否则(DX) ←FFFFH BCD码调整指令加减运算非压缩BCD码高4位的值可不为0，乘除时高4位必须是0。 压缩BCD码调整指令 DAA ：对BCD码加法运算结果(AL)进行调整。 DAS ：对BCD码减法运算结果(AL)进行调整。 非压缩BCD码调整 AAA ：对非压缩BCD码加法运算结果进行调整，进位送(AH)中 AAS ：对非压缩BCD码减法运算结果进行调整 AAM ：对非压缩BCD码乘法运算进行调整 AAD ：对非压缩BCD码除法运算进行调整 逻辑指令逻辑运算指令 AND DST,SRC (DST) ←(DST)&amp;(SRC) OR DST,SRC (DST) ←(DST)|(SRC) NOT DST ~DST XOR DST,SRC (DST) ←(DST)^(SRC)//异或 TEST DST,SRC (DST)&amp;(SRC),仅影响标志位 移位指令 逻辑左移指令 SHL DST,count ：DST左移count位，每左移一位，最低位补0，最高位进入CF 算术左移指令 SAL DST,count ：同SHL 逻辑右移指令 SHR DST,count ：最高位添零，最低位进入CF 算术右移指令 SAR DST,count ：最高位不变，最低位进入CF 循环左移指令 ROL DST,count ：最高位进入CF和最低位 循环右移指令 ROR DST,count ：最低位进入CF和最高位 带进位循环左移指令 RCL DST,count 带进位循环右移指令 RCR DST,count count可以为1，也可以为CL做移位计数 串处理指令数据串传送指令唯一的目的操作数和源操作数都在存储器中的指令 串传送指令 MOVSB/MOVSW ：DST与SRC做类型检查 MOVSB ： ((ES:DI)) ←((DS:SI)),(SI) ←(SI)±1, (DI)←(DI)±1 MOVSW ：((ES:DI)) ←((DS:SI)),(SI) ←(SI)±2, (DI) ←(DI)±2其中，加、减地址指针SI和DI由FLAG中的DF决定，DF=0地址增加，DF=1地址减小。 建立方向标志指令 CLD ;DF←0 STD ;DF←1 REP重复前缀例：REP MOVSB ：以CX寄存器做计数器，每传送一个数(CX)减1，直到(CX)为0REPZ/REPE : 若(CX)≠0且ZF=1时继续执行，否则退出REPNZ/REPNE : 若(CX)≠0且ZF=0（比较不相等）时继续执行，否则退出 存入串指令 STOSB/STOSW ： DST做类型检查 STOSB ： ((ES:DI)) ←(AL), (DI) ←(DI)±1 STOSW ： ((ES:DI)) ←(AX),(DI) ←(DI)±2由DF决定方向，可加入前缀REP 从串中取指令 LODSB/LODSW ：SRC做类型检查 LODSB ： (AL) ←((DS:SI)) , (SI) ←(SI)±1 LODSW ： (AX) ←((DS:SI)) ,(SI) ←(SI)±2地址增减由DF决定 字符串扫描和比较指令 串比较指令 CMPS : SRC和DST仅做类型检查 CMPSB ;((DS:SI))-((ES:DI)), (SI) ←(SI)±1, (DI) ←(DI)±1 CMPSW ;((DS:SI))-((ES:DI)), (SI) ←(SI)±2, (DI) ←(DI)±2串比较仅影响标志,地址增减由DF决定。 串扫描指令 SCAS : DST做类型检查 SCASB ： (AL)-((ES:DI)) ，(DI) ←(DI)±1 SCASW ： (AX)-((ES:DI)) ,(DI) ←(DI)±2仅影响标志，地址增减由DF决定，可加条件前缀。 控制转移指令无条件转移指令：JMP TARGET JMP short_label ：(IP)&lt;-(IP)+short_label 短跳转 JMP near_label ：(IP)&lt;-(IP)+near_label 近跳转 JMP far_label ：(CS:IP)&lt;-far_label 远跳转 条件转移指令 根据单个标志转移 指令 含义 测试条件 JZ short_label 结果为0转移 ZF=1 JE short_label 结果相等转移 ZF=1 JNZ short_label 结果不为0则转移 ZF=0 JNE short_label 结果不相等则转移 ZF=0 JS short_label 结果为负则转移 SF=1 JNS short_label 结果非负则转移 SF=0 JNO short_label 结果不溢出则转移 OF=0 JO short_label 结果溢出则转移 OF=1 JP short_label 奇偶为1则转移 PF=1 JPE short_label 偶转移 PF=1 JNP short_label 奇偶为0则转移 PF=0 JPO short_label 奇转移 PF=0 JB short_label 有借位转移 CF=1 JNAE short_label 不大于等于转移 CF=1 JC short_label 有进位转移 CF=1 JNB short_label 无借位转移 CF=0 JAE short_label 大于等于转移 CF=0 JNC short_label 无进位转移 CF=0 两个无符号数比较转移 A大于 B小于 E等于 JB/JNAE/JC CF=1 小于 JNB/JAE/JNC CF=0 不小于 JBE/JNA CF&#124;ZF=1 不大于 JNBE/JA CF&#124;ZF=0 大于 两个有符号数比较转移 G大于 L小于 E等于 JL/JNGE SF^OF=1 小于 JNL/JGE SF^OF=0 不小于 JNLE/JG (SF^OF)&#124;ZF=0 大于 JLE /JNG (SF^OF)&#124;ZF=1 不大于 测试CX值，为0则转移JCXZ short_label ：(CX)=0则转移 循环指令 LOOP short_label ： (CX) ←(CX)-1,(CX)≠0则转移 LOOPZ/LOOPE short_label ： (CX) ←(CX)-1,(CX)≠0且ZF=1则转移LOOPNZ/LOOPNE short_label ：(CX) ←(CX)-1,(CX)≠0且ZF=0则转移 子程序调用与返回 子程序调用指令 CALL TARGET具体指令 CALL near_proc;段内调用 CALL far_proc;段间调用 CALL mem16/regp16/mem32 返回指令 RET 带立即数返回 RET IMM16在RET指令的基础上，当从堆栈中弹出IP和CS后，再将SP加上一个字的立即数，使得返回后(SP) ← (SP) + IMM16 中断调用与返回中断调用 INT n依次将FLAG，当前CS和IP（即断点地址）放入堆栈，清除IF和TF。执行中断类型码为n的中断服务程序。注： INT n 的机器码为 CDH n，INT 3 的机器码特殊，为 CCH INTO在有符号数运算结束以后，可以使用INTO，若OF=1，则执行中断指令INT 4，否则无操作。 中断返回指令 IRET从中断程序返回主程序，恢复断点和FLAG 控制类指令标志处理指令 CLC/STC/CMC 对CF 清0 / 置位 /取反 CLD/STD 对DF 清0 / 置位 CLI/STI 对IF 清0 / 置位 处理器控制指令 NOP 空操作指令 占用一个字节的机器码，不执行任何操作 HLT (Halt)停机指令 该指令使处理器处于停机状态，以便等待一次外部中断到来 WAIT 等待指令 该指令使处理器处于空转状态，也可用来等待外部中断的到来 ESC (Escape)换码指令,用作前缀 格式：ESC MEM，其中MEM指出一个存储单元，ESC指令把该存储单元的内容送到数据总线去 LOCK 封锁指令,用作前缀 该指令与其他指令联合，用来维持总线的封锁信号直到与其联合的指令执行完为止]]></content>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16位微处理器8086]]></title>
    <url>%2F2017%2F11%2F01%2F16%E4%BD%8D%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A88086%2F</url>
    <content type="text"><![CDATA[执行单元(EU－Execution Unit)负责指令的译码和执行。 4个16位数据寄存器（AX、BX、CX、DX）AX和AL可用作累加操作，因此又称作累加器 4个16位地址指针寄存器：通常用于存放操作数偏移地址 SP (Stack Pointer)—堆栈指针寄存器，指示堆栈段栈顶位置 BP (Base Pointer)—基址指针寄存器，指示堆栈段数据区基址 SI (Source Index)—源变址寄存器，指示数据段源串地址 DI(Destination Index)—目的变址寄存器，指示扩展段目的串地址 标志寄存器 FLAG 状态标志 CF（Carry Flag）进(借)位标志，加法运算最高位产生进位或减法运算最高位产生借位，表示无符号数运算产生溢出，CF置1，否则置0 AF（Auxiliary Carry Flag）辅助进位标志，加法运算时第3位往第4位有进位，或减法运算时第3位往第4位有借位，则AF置1，否则置0 ZF (Zero Flag）零标志, 若当前运算结果为零, 则ZF置1,否则置0 SF（Sign Flag）符号标志，与运算结果最高位相同，若为负数，则SF置1，否则置0，SF指示了当前运算结果是正还是负 OF（Overflow Flag）溢出标志，有符号数算术运算结果溢出，则OF置1，否则置0 PF（Parity Flag）奇偶标志，运算结果低8位所含1个数为偶数则PF置1，否则置0 控制标志 DF（Direction Flag）方向标志DF=1，串操作时，地址不断递减；DF=0，串操作时，地址不断递增 IF（Interrupt enable Flag）中断允许标志IF=1，CPU允许接收可屏蔽中断请求，即开中断；IF=0，则关中断 TF（Trap Flag）跟踪标志，又称单步标志TF=1，CPU为单步工作方式，每执行完一条指令产生一次软件中断 总线接口单元（BIU－Bus Interface Unit）与系统总线连接，实现与存储器、I/O口之间的数据传送。 4个16位段地址寄存器 CS (Code Segment)——代码段寄存器，代码段存放代码 DS (Data Segment）——数据段寄存器，数据段存放数据 SS (Stack Segment)——堆栈段寄存器，堆栈段用作堆栈操作 ES (Extra Segment)——扩展段寄存器，扩展段存放数据 8086对存储器采用分段管理，4个段寄存器分别存放4个当前段的起始地址，又称作段基址寄存器。 指令指针寄存器IP (Instruction Pointer)16位IP存放当前代码段(CS)所要取出的下一条指令的偏移地址 地址加法器∑8086用20位地址线寻址1MB内存空间，但其内部寄存器是16位的，因此需要用地址加法器∑根据16位寄存器的值计算出20位物理地址 指令缓冲队列8086执行指令的同时，会从内存取1条或几条指令，取来的指令就存放在指令队列中 暂存器用于与EU通信的内部寄存器 总线控制电路负责总线操作控制 存储器和I/O管理逻辑地址形式为 段地址 : 偏移地址 段超越 8086 I/O编址8086对I/O端口操作，需要专门的IN、OUT指令，并且只能通过累加器（AX/AL）来完成例： IN AL, 80H 8086系统中，存储器和I/O端口分别独立编址存储器的地址范围是00000H – 0FFFFFHI/O端口的地址范围是0000H – 0FFFFH 8086引脚信号和工作模式最小模式：系统中只有一个处理器;$MN/\overline{MX}$为高电平最大模式：系统中包括两个或多个处理器;$MN/\overline{MX}$为低电平8086 CPU为40pin双列直插（DIP)封装。 8086最小模式下引脚信号和功能 总线信号 AD0～AD15: 地址/数据复用引脚，双向工作分时传送16位数据和地址的低16位，由ALE锁存地址信息 A16～A19（S3～S6）: 地址/状态复用引脚，输出分时输出地址的高4位和CPU当前状态，地址信息由ALE锁存 $\overline{BHE}/S7$: 高8位数据总线允许/状态复用引脚，输出低电平有效，表示高8位数据线D15～D8上数据有效 ALE: 地址锁存允许信号输出高电平有效，表示总线上的信息是地址信息。 总线控制信号 HOLD: 总线保持请求信号输入高电平有效，表示其他模块（如DMA)申请占用总线 HLDA: 总线保持响应信号输出高电平有效，表示CPU已让出总线 系统控制信号 $M/\overline{IO}$: 存储器/输入输出选择信号，输出，高电平表示CPU访问存储器，低电平表示CPU访问I/O端口 $\overline{RD}$: 读信号输出，低电平有效，表示CPU从存储器或I/O口读入信息 $\overline{WR}$: 写信号输出，低电平有效，表示CPU向存储器或I/O口输出数据 $DT/\overline{R}$: 数据收发信号输出，高电平表示CPU正在发送数据，低电平表示CPU接收数据 $\overline{DEN}$: 数据允许信号输出，低电平有效，表示CPU当前准备发送或接收一个数据 中断控制信号 INTR: 可屏蔽中断请求信号输入，高电平有效，表示外部向CPU提出中断申请 $\overline{INTA}$: 中断响应信号输出，低电平有效，表示CPU响应外设中断请求 NMI: 非屏蔽中断请求信号输入，上升沿有效。表示外部有非屏蔽中断申请。非屏蔽中断不受软件控制，CPU必须响应 CPU控制信号 RESET: 复位信号输入高电平有效，至少保持4个时钟周期的高电平。复位时CPU停止现行操作，开始复位，并进行初始化：标志寄存器FLAG、IP、DS、SS、ES及指令队列均清零，CS为FFFFH，复位结束时CPU从FFFF0H开始执行程序 $MN/\overline{MX}$：最小模式/最大模式选择信号输入，高电平为最小模式 READY：“准备好”信号输入，高电平有效，表示存储器或I/O口已准备就绪，可进行一次数据传输 $\overline{TEST}$: 测试信号输入，低电平有效，有效时CPU退出WAIT指令； 其它信号 CLK: 时钟信号，8086主频为4.77MHZ T=210ns；单相，占空比为1/3 VCC,GND: 电源及地，+5V，满足TTL规范 8086最小模式下的总线连接Intel 8282把AD复用引脚连接到地址总线的8位地址锁存器。3片8282(功能同74LS373)A0～A19和$\overline{BHE}$，$ALE$为锁存信号。 Intel 8286把AD复用引脚连接到数据总线的8位数据缓冲器。2片8286(功能同74LS245)做D15～D0的缓冲器，$DT/\overline{R}$做方向选择，$\overline{DEN}$为选通信号。 控制信号$M/\overline{IO}$、$\overline{RD}$和$\overline{WR}$ 中断控制信号INTR、$\overline{INTA}$、NMI INTR: 外部可屏蔽中断请求引脚，高电平有效 $\overline{INTA}$: 中断响应信号，低电平有效 NMI: 不可屏蔽中断请求引脚，上升沿有效 总线控制信号HOLD、HLDA HOLD：总线保持请求引脚,高电平有效 HLDA：总线保持响应引脚，高电平有效HLDA控制8282的OE，当CPU总线保持响应时让出总线 8086操作和时序1． 8086时钟电路与复位电路8284为8086提供CLK时钟信号、 RESET复位信号和READY准备信号8086/8088内部无时钟发生器，时钟由8284提供，频率为4.77MHz输入RES经8284内部斯密特触发器整形，同步后产生RESET信号,给CPU复位外界准备好信号输入到8284的RDY端，同步后产生READY信号给CPU 2． 8086/8088系统的复位操作和启动过程 CPU接到RESET信号，停止现有工作，进行复位操作：CS置FFFFH，IP置0，指令队列清空，其余寄存器清0 从存储器FFFFH :0000H取第一条指令，一般在此处放一条跳转指令，跳转到ROM BIOS中的系统测试程序 系统测试程序执行硬件自检(对CPU、RAM、ROM等硬件进行测试)，然后执行ROM BIOS中的初始引导程序 初始引导程序再从磁盘0面0道1扇区装入引导程序，执行引导操作 按引导程序的指令，顺序装入其他程序模块，完成操作系统的引导操作 注：在3、4步之间微机还会检查C0000H开始的扩展ROM空间中是否有程序，如果有，并且校验正确，则先执行这些程序 3． 8086总线周期 时钟周期T（T状态）时钟脉冲的一个循环时间叫做一个时钟周期。每个时钟周期T又称为一个“状态”。它是CPU工作的最小时间单位，是计算机系统工作速度的重要标志。8086 CPU的F=4.77M，T=210ns 总线周期CPU通过总线从存储器或I/O端口存取一个字或字节的时间称为总线周期。包括三类：存储器读写周期、I/O端口读写周期、中断响应周期一个基本总线周期包括4个状态：T1，T2，T3，T4 指令周期执行一条指令所需要的时间称为指令周期。8086指令周期最短为2个时钟周期，最长为200个时钟周期 4． 8086总线操作时序（最小模式下存储器读周期） T1状态置$M/\overline{IO}$为高电平，指示是从存储器读数据T1开始，ALE置高，8282输出跟随输入，T1上升沿，ALE置低,8282锁存20位地址$\overline{BHE}$也在T1状态锁存，指示T2、T3状态传送数据时，高8位是否有效置$DT/\overline{R}$为低，控制8286接收数据，置$\overline{DEN}$为高，让8286输出浮空 T2状态撤销地址信号，AD15～AD0处于高阻状态，为读入数据作准备A19/S6～A16/S3及$\overline{BHE}/S7$引脚输出状态信息S6～S3置$\overline{RD}$信号为低电平，输出读信号到存储器置$\overline{DEN}$为低电平，打开8286三态门，准备接收存储器输出的数据 T3状态存储器将数据送到数据总线，CPU通过AD15～AD0接收数据T3上升沿检测READY信号，若为高电平，则下一个为T4状态；否则插入等待周期Tw T4状态T4开始，撤销$\overline{RD}$和$\overline{DEN}$信号，置为高电平无效，数据总线浮空T4上升沿撤销$DT/\overline{R}$信号CPU读取存储器数据的时间为 2T = 420ns （$\overline{RD}$或$\overline{DEN}$有效时间） 注：最小模式下I/O口读周期与存储器读周期类似，区别为读I/O口时，T1状态将置$M/\overline{IO}$为低电平，表示是对I/O口进行读]]></content>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微型计算机概述]]></title>
    <url>%2F2017%2F10%2F05%2F%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1．冯.诺依曼结构:运算器、控制器、存储器、输入设备和输出设备 2．微型计算机(主机):CPU、存储器、输入/输出接口（I/O口）、系统总线（BUS） 3．微型计算机系统（MCS—Micro-Computer System）是以微型计算机（主机）为核心，配上外围设备、电源和软件等，能独立工作的完整计算机。 4．CPU片内数据总线的宽度决定了计算机的位数，准16/32位机是指CPU片内数据线的宽度为16/32位，片外数据线的宽度为8/16位。 5．‘0’～‘9’,‘A’～‘F’的ASCII码表示为30H～39H,41H～46H 6．缓冲输出驱动能力强，如果一个芯片是缓冲输出，那么输出拉电流可达15mA，灌电流可达20mA。 7．非缓冲输出驱动能力较弱（拉电流能力很弱，灌电流能力较强），如果一个芯片是非缓冲输出，那么输出拉电流一般为400μA，灌电流可达8mA。 8．三态门（缓冲器）：增加驱动，用作数据输入时的缓冲(数据总线) 单向三态缓冲器——74LS244 双向三态缓冲器——74LS245、INTEL 8286 9．D触发器（锁存器）：信号保持，用作信息输出时的锁存(地址总线) 具有异步清零的TTL上升沿锁存器——74LS273 具有缓冲输出的TTL低电平锁存器——74LS373、INTEL 8282]]></content>
      <tags>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言格式输出函数printf详解]]></title>
    <url>%2F2017%2F09%2F28%2FC%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0printf%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[printf函数调用的一般形式为:​ printf(“格式控制字符串”, 输出表列) 格式字符串在Turbo C中格式字符串的一般形式为： [标志][输出最小宽度][.精度][长度]类型。如：printf(&quot;%-10.3lf&quot;,a)其中方括号[]中的项为可选项。各项的意义介绍如下。 标志标志字符为 -、+、# 和空格四种，其意义下表所示： 标志 意义 - 结果左对齐，右边填空格 + 输出符号(正号或负号) 空格 输出值为正时冠以空格，为负时冠以负号 # 对c、s、d、u类无影响 输出最小宽度用十进制整数来表示输出的最少位数。若实际位数多于定义的宽度，则按实际位数输出，若实际位数少于定义的宽度则补以空格或0。 精度精度格式符以“.”开头，后跟十进制整数。本项的意义是：如果输出数字，则表示小数的位数；如果输出的是字符，则表示输出字符的个数；若实际位数大于所定义的精度数，则截去超过的部分。 长度长度格式符为h、l两种，h表示按短整型量输出，l表示按长整型量输出。 类型类型字符用以表示输出数据的类型，其格式符和意义如下表所示： 字符 意义 o 以八进制形式输出无符号整数(不输出前缀0) d 以十进制形式输出带符号整数(正数不输出符号） u 以十进制形式输出无符号整数 x,X 以十六进制形式输出无符号整数(不输出前缀0x) f 以小数形式输出单、双精度实数 e,E 以指数形式输出单、双精度实数 g,G 以%f或%e中较短的输出宽度输出单、双精度实数 c 输出单个字符 s 输出字符串 对o类，在输出时加前缀o；对x类，在输出时加前缀0x；对e、g、f 类当结果有小数时才给出小数点。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASCII码表]]></title>
    <url>%2F2017%2F09%2F20%2FASCII%E7%A0%81%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[ASCII控制字符 二进制 十进制 十六进制 缩写 名称/意义 0000 0000 0 00 NUL 空字符（Null） 0000 0001 1 01 SOH 标题开始 0000 0010 2 02 STX 本文开始 0000 0011 3 03 ETX 本文结束 0000 0100 4 04 EOT 传输结束 0000 0101 5 05 ENQ 请求 0000 0110 6 06 ACK 确认回应 0000 0111 7 07 BEL 响铃 0000 1000 8 08 BS 退格 0000 1001 9 09 HT 水平定位符号 0000 1010 10 0A LF 换行键 0000 1011 11 0B VT 垂直定位符号 0000 1100 12 0C FF 换页键 0000 1101 13 0D CR 归位键 0000 1110 14 0E SO 取消变换（Shift out） 0000 1111 15 0F SI 启用变换（Shift in） 0001 0000 16 10 DLE 跳出数据通讯 0001 0001 17 11 DC1 设备控制一（XON 启用软件速度控制） 0001 0010 18 12 DC2 设备控制二 0001 0011 19 13 DC3 设备控制三（XOFF 停用软件速度控制） 0001 0100 20 14 DC4 设备控制四 0001 0101 21 15 NAK 确认失败回应 0001 0110 22 16 SYN 同步用暂停 0001 0111 23 17 ETB 区块传输结束 0001 1000 24 18 CAN 取消 0001 1001 25 19 EM 连接介质中断 0001 1010 26 1A SUB 替换 0001 1011 27 1B ESC 跳出 0001 1100 28 1C FS 文件分割符 0001 1101 29 1D GS 组群分隔符 0001 1110 30 1E RS 记录分隔符 0001 1111 31 1F US 单元分隔符 0111 1111 127 7F DEL 删除]]></content>
      <tags>
        <tag>ASCII</tag>
        <tag>编程</tag>
        <tag>汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[debug命令]]></title>
    <url>%2F2017%2F09%2F19%2Fdebug%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[r 查看、修改当前寄存器值 d 查看内存地址段的内容 e 修改内存地址中的内容（机器码） u 将内存地址段的内容翻译为指令 t 执行CS:IP处的指令，一条 a 以汇编格式写入在内存中写入一条指令]]></content>
      <tags>
        <tag>汇编</tag>
        <tag>计算机原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notes of C++ Primer Plus]]></title>
    <url>%2F2017%2F04%2F14%2FNotes-of-C%2B%2B-Primer-Plus%2F</url>
    <content type="text"><![CDATA[通常，IDE允许在辅助窗口中运行程序。程序执行完毕后，有些IDE将关闭该窗口，而有些IDE则不关闭。如果编译器关闭窗口，将难以看到程序的输出，除非程序员眼疾手快，且过目不忘。为查看输出，必须在程序的最后加上一些代码： 123cin.get();cin.get();return 0; cin.get()语句读取下一次键击，因此上述语句让程序等待，直到按下了Enter键（在按下Enter之前，键击将不被发送给程序，因此按其他键都不管用）。如果程序在其常规输入后留下一个没有被处理的键击，则第二条语句是必需的。例如，如果要输入一个数字，则需要输入该数字，然后按Enter键。程序将读取该数字，但Enter键不被处理，这样它将被第一个cin.get()读取。 控制符dec、hex和oct，分别用于指示cout以十进制、十六进制和八进制格式显示整数 后缀是放在数字常量后面的字母，用于表示类型。整数后面的l或L后缀表示该整数为long常量，u或U后缀表示unsigned int常量，ul（可以采用任何一种顺序，大写小写均可）表示unsigned long常量（由于小写l看上去像1，因此应使用大写L作后缀）。例如，在int为16位、long为32位的系统上，数字22022被存储为int，占16位，数字22022L被存储为long，占32位。同样，22022LU和22022UL都被存储为unsigned long。 cout.put()函数输出一个字符,如 123char ch='c';cout.put(ch);cout.put('!'); 输出为 1c! 成员函数归类所有，描述了操纵类数据的方法。例如类ostream有一个put()成员函数，用来输出字符。只能通过类的特定对象（例如这里的cout对象）来使用成员函数。要通过对象（如cout）使用成员函数，必须用句点将对象名和函数名称（put()）连接起来。句点被称为成员操作符。cout.put()的意思是，通过类对象cout来使用函数put()。 Unicode提供了一种表示各种字符集的解决方案——为大量字符和符号提供标准数值编码，并根据类型将它们分组。例如，ASCII码成为Unicode的子集，因此在这两种系统中，美国的拉丁字符（如A和Z）的表示相同。不过，Unicode还包含其他拉丁字符，如欧洲语言使用的拉丁字符、来自其他语言（如希腊语、西里尔语、希伯来语、阿拉伯语、泰语和孟加拉语）中的字符以及象形文字（如中国和日本的文字）。到目前为止，Unicode可以表示96000多种符号和49个手写符号（script），它还在不断发展中。要了解更多有关的知识，请登录Unicode联盟的网站。 国际标准化组织（ISO）建立了一个工作组，专门开发ISO 10646——这也是一个对多种语言文本进行编码的标准。ISO 10646小组和Unicode小组从1991年开始合作，以确保他们的标准同步。 程序需要处理的字符集可能无法用一个8位的字节表示，如日文汉字系统。对于这种情况，C++的处理方式有两种。首先，如果大型字符集是实现的基本字符集，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型wchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。 cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t类型。iostream头文件的最新版本提供了作用相似的工具——wcin和wcout，可用于处理wchar_t流。另外，可以通过加上前缀L来指示宽字符常量和宽字符串。下面的代码将字母P的wchar_t版本存储到变量bob中，并显示单词tall的wchar_t版本： 12wchar_t bob = L'F';wcout &lt;&lt; L"tall" &lt;&lt; endl; 任何数字值或指针值都可以被隐式转换（即不用显式强制转换）为bool值 const限定符 格式:const type name = value;如const int MONTHS = 12;则程序可以用MONTHS代替12，MONTHS被初始化后不能更改 强制转换的通用格式 第一种格式来自C语言，第二种格式是纯粹的C++。新格式的想法是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。 ​]]></content>
      <tags>
        <tag>编程</tag>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
